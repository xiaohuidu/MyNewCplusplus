<< [Back](https://github.com/xiaohuidu/MyNewCplusplus/blob/af63fde92e4824261e7ecb7e1e189c6f5001c2b3/C++11%E6%96%B0%E7%89%B9%E6%80%A7.md)

在C++ 11中， 一共有5种值类型(value):
-   **左值(lvalue)** (Left-hand-side value) ：a glvalue that is not an xvalue
-   **右值(rvalue)** (Right-hand-side value)  ：is a prvalue or an xvalue.
-   **将亡值(xvalue)** (eXpiring value) ：is a glvalue that denotes an object or bit-field whose resources can be reused （usually because it is near the end of its lifetime）.
-   **纯右值(prvalue)** (Pure rvalue)：an expression whose evaluation initializes an object or a bit-field, or computes the value of an operand of an operator, as specified by the context in which it appears, or an expression that has type cv void.
-   **泛左值(glvalue)** (Generalized lvalue) ： an expression whose evaluation determines the identity of an object, bit-field, or function

它们的关系是：
- **lvalue** 和 **xvalue** 合称为 **glvalue**。
- **prvalue** 和 **xvalue** 合称为 **rvalue**。

![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/ovj7lpfqxu.png)


"在C++中所有值要不就是左值， 要不就是右值" 这句话今天仍然正确。不过现在更准确的说法是：“在C++中所有值要不就是左值， 要不就是将亡值， 要不就是纯右值。”

**这五种类别的分类基于表达式的两个特征：**
-   **是否拥有身份（identity）**：可以确定表达式是否与另一表达式指代同一实体，例如比较它们所标识的对象或函数的（直接或间接获得的）地址；
-   **是否可被移动**（具体见下文）：移动构造函数、移动赋值运算符或实现了移动语义的其他函数重载能够绑定到这个表达式。

由此，C++11中对于这五种类别定义如下：

-   **lvalue是指：拥有身份且不可被移动的表达式。**
-   **xvalue是指：拥有身份且可被移动的表达式。**
-   **prvalue是指：不拥有身份且可被移动的表达式。**
-   **glvalue是指：拥有身份的表达式**，lvalue和xvalue都是glvalue。
-   **rvalue是指：可被移动的表达式**。prvalue和xvalue都是rvalue。

这么说起来还是有些拗口，不过其实颠来倒去就是两个特征的“是”与“否”，所以通过一个2x2的表格就很容易描述清楚了：

|  |拥有身份（glvalue）  |不拥有身份  |
|--|--|--|
| 可移动（rvalue） | xvalue |prvalue |
| 不可移动 | lvalue|不存在|



> 注：不存在不拥有身份也不可移动的表达式。

我们可以通过下面这个图来记忆五种类别的关系：

![](https://paul-pub.oss-cn-beijing.aliyuncs.com/2020/2020-07-cpp-copy-move/value_cat.png)

每种值类别都有其关联的性质，这些性质决定了表达式可以如何使用。
## glvalue

glvalue是拥有身份的表达式，它对应了一块内存地址。glvalue有lvalue和xvalue两种形式，具体的示例见下文。

glvalue具有以下一些特性：

-   glvalue可以自动转换成prvalue。例如：`int a = b`，等号右边的lvalue会自动转换成rvalue。
-   glvalue可以是多态的（polymorphic），它所对应了动态类型和静态类型可以不一样，例如：一个指向子类的父类指针。
-   glvalue可以是不完整类型，只要表达式允许。例如：由前置声明但未定义的类类型。

## rvalue

rvalue是指可以移动的表达式。prvalue和xvalue都是rvalue，具体的示例见下文。

rvalue具有以下特征：

-   无法对rvalue进行取地址操作。例如：`&42`，`&i++`，这些表达式没有意义，也编译不过。
-   rvalue不能放在赋值或者组合赋值符号的左边，例如：`3 = 5`，`3 += 5`，这些表达式没有意义，也编译不过。
-   rvalue可以用来初始化const左值引用（见下文）。例如：`const int& a = 1`。
-   rvalue可以用来初始化右值引用（见下文）。
-   rvalue可以影响函数重载：当被用作函数实参且该函数有两种重载可用，其中之一接受右值引用的形参而另一个接受 const 的左值引用的形参时，右值将被绑定到右值引用的重载之上。

下面是三种具体的值类别：

## lvalue

左值是指拥有身份但不可移动的表达式。

变量，函数或者数据成员的名称都是左值表达式。下面是一些左值的例子：


####  右值引用，移动语义和完美转发
#### 1.  左值和右值，左值引用和右值引用的定义
左值和右值的区分: **可以取地址则为左值， 不可取地址则为右值**。
- **左值(lvalue）**: 是表达式结束后依然存在的 **持久对象** (代表一个在内存中占有确定位置的对象),  可以取地址，具名变量或对象。
- **右值(rvalue)**是表达式结束时不再存在的**临时对象**(不在内存中占有确定位置的表达式), 不可以取地址，没有名字。

**赋值运算符(=)左边只能出现左值， 右边可以是左值或者右值。**

```c
int a;
int b;

a = 3;
b = 4;
a = b;
b = a;

// 以下写法不合法。
3 = a;
a + b = 4; // a+ b是右值， 不能出现在 复制运算符= 的左边
```
**在所有字面量(literal), 只有 string literal 是 lvalue, 其他 literal 是 rvalue：**

```
cout << &"www" << endl; //合法
cout << &'w' << endl; 非法 
```
**右值只能出现在内置赋值操作符(=)的右边， 这里强调是内置赋值操作符**。`string("hello")` 是 rvalue，但可以出现在左边：**`string("hello") = string("world")`**。注意，这个等号是 string class 定义的 operator=，不是 C++ **内置**

```cpp
#include <string>
#include <iostream>
using namespace std;

void func(string s)
{
        cout << s << endl;
}

int main()
{
        func(string("hello") = string("world"));
        return 0;
}
```
打印结果:
```
world
```
- **左值引用（lvalue reference）**:  就是对左值的引用，给左值取别名。主要作用是**避免对象拷贝**。
左值引用的表示是**在具体的变量类型名称后加 &**:
```
// 以下几个是对左值的左值引用
int& ra = a; 
int*& rp = p; 
int& r = *p; 
const int& rb = b;
```
- **右值引用(rvalue reference)**: 就是对右值的引用，给右值取别名。主要作用是把**延长对象的生命周期**，一般是延长到作用域的scope之外。
右值引用的表示是**在具体的变量类型名称后加 &&**:

```c 
int&& rr = 4;
double&& rr2 = x + y; 
double&& rr3 = fmin(x, y);
```
> 右值引用的加入是C++ 11 最重大语言特性之一。\
> 从实践角度讲，它能够完美解决C++中长久以来为人所诟病的**临时对象效率问题**。\
> 从语言本身讲，它健全了C++中的引用类型在左值右值方面的缺陷。\
> 从库设计者的角度讲，它给库设计者又带来了一把利器。\
> 从库使用者的角度讲，不动一兵一卒便可以获得“免费的”效率提升。

**左值引用和右值引用本身都是左值**

右值引用 引用 右值，会**使右值被存储到特定的位置**。
也就是说，**右值引用变量其实是左值**，**可以对它取地址**和赋值（const右值引用变量可以取地址但不可以赋值，因为 const 在起作用）。
当然，取地址是指取变量空间的地址（**右值是不能取地址的**）。
比如：
1.  double&& rr2 = x + y;　　\
&rr2;　\
rr2 = 9.4;　　\
右值引用 rr2 引用右值 x + y 后，该表达式的返回值被存储到特定的位置，不能取表达式返回值 x + y 的地址，但是可以取 rr2 的地址，也可以修改 rr2 。 
2. const double&& rr4 = x + y;　　\
&rr4;　　\
可以对 rr4 取地址，但不能修改 rr4，即写成rr4 = 5.3;会编译报错

 #### 2. 左值引用和右值引用的指向
-   **左值引用可以指向左值， 也可以指向右值，但需要const来修饰，不能修改这个值**
```c
// 1.左值引用只能引用左值
int t = 8;
int& rt1 = t;
//int& rt2 = 8; // 编译报错，因为8是右值，不能直接引用右值

// 2.但是const左值引用既可以引用左值, 也可以引用右值
const int& rt3 = t;
const int& rt4 = 8; //  const int& rt4本质上也是一个常量，指向一个不能被修改的右值，也是安全的
const double& r1 = x + y;
const double& r2 = fmin(x, y);
```
**>问：为什么const左值引用也可以引用右值？** \
答：在 C++11标准产生之前，是没有右值引用这个概念的，当时如果想要一个类型既能接收左值也能接收右值的话，需要用const左值引用，比如标准容器的 push_back 接口：void push_back (const T& val)。
也就是说，如果const左值引用不能引用右值的话，有些接口就不好支持了。  
另外，const左值引用，本意上是指向一个不被（该引用本身）它修改的内存区域，本质上这个引用变量本身也就是一个常量，至于这个内存区域对应一个全局变量、局部变量、xvalue，无所谓啊

下面就是 C++98标准中相关接口const左值引用引用右值的例子：
```
vector<int> v;
v.push_back(1);
v.push_back(2);
v.push_back(3);
```
-   **右值引用可以指向右值， 也可以指向左值，需要std::move(v)即可**
> std::move（C++11），作用是将一个左值强制转化为右值，以**实现移动语义**。左值被 move 后变为右值，于是右值引用可以引用。
```c
// 1.右值引用只能引用右值
int&& rr1 = 10;
double&& rr2 = x + y;
const double&& rr3 = x + y;

int t = 10;
//int&& rrt = t; // 编译报错，不能直接引用左值

// 2.但是右值引用可以引用被move的左值
int&& rrt = std::move(t);
int*&& rr4 = std::move(p);
int&& rr5 = std::move(*p);
const int&& rr6 = std::move(b);
```

看一下下面这个例子:
```cpp
template<typename T>
class Widget {
    ...
    Widget(Widget&& rhs);        // rhs类型是右值引用, 但它本身是个左值
    ...                          
};
```
在 Widget 的构造函数当中,  `rhs`  是一个右值引用，**前面提到，右值引用只能被绑定到右值上**，所以我们知道它被绑定到了一个右值上面(i.e., 因此我们需要传递了一个rvalue给它)， 但是  `rhs`  本身是一个 左值，所以，当我们想要用到这个被绑定在  `rhs`  上的右值的 rvalueness 的时候，我们就需要把  `rhs`  转换回一个rvalue。之所以我们想要这么做，是因为我们想将它作为一个移动操作的source，这就是为什么我们**用  `std::move`将它转换回一个  `rvalue`**。
#### 3. 万能引用(universal reference)
**并不是所有出现&&的地方都是右值引用, 有可能是万能引用**
```cpp
Widget&& var1 = someWidget; // here, “&&” means rvalue reference 
auto&& var2 = var1; // here, “&&” does not mean rvalue reference
 
template<typename T>
void f(std::vector<T>&& param); // here, “&&” means rvalue reference
 
template<typename T>
void f(T&& param); // here, “&&”does not mean rvalue reference
```

类型声明当中的“`&&`”有的时候意味着右值引用，但有的时候意味着右值引用或者左值引用。因此，源代码当中出现的 “`&&`” 有可能是 “`&`” 的意思，即是说，语法上看着像右值引用 (“`&&`”)，但实际上却代表着一个左值引用 (“`&`”)。 我没给它起个名字叫**万能引用**(universal reference)

**如果一个变量或者参数被声明为T&&，其中T是被推导的类型，那这个变量或者参数就是一个万能引用。**

万能指针存在于下面几种情况:
- **函数模板的参数**。
- **使用auto的时候**。
- **typedef**
- **decltype**

**万能引用的initializer决定了它到底代表的是左值引用 还是 右值引用**:

-   如果**用来初始化universal reference的表达式是一个左值**，那么universal reference就变成**lvalue reference**。
-   如果**用来初始化universal reference的表达式是一个右值**，那么universal reference就变成**rvalue reference**。

上述可以根据下面代码例子理解：
```cpp
template<typename T> void f(T&& param); 
```

假设你是`initializer`：
```cpp
int a;
f(a);   // 传入左值,那么上述的T&& 就是lvalue reference,也就是左值引用绑定到了左值
f(1);   // 传入右值,那么上述的T&& 就是rvalue reference,也就是右值引用绑定到了左值
```
`auto` 和模版类似。
```cpp
Widget&& var1 = someWidget;
auto&& var2 = var1; // var2 定义为一个universial reference, 
					// 赋值左值引用后， 变成了左值引用（var1 变量本身是左值）
```
**只有在发生类型推导的时候  “`&&`” 才代表 universal reference** 。**如果没有类型推导，就没有universal reference**。这种时候，类型声明当中的“`&&`”总是代表着rvalue reference。因此，如下代码没有发生类型推导， &&代表rvalue reference:
```cpp
template<typename T> void f(T&& param); // 需要类型推导， 所以是万能引用
 
template<typename T>
class Widget {
    ...
    Widget(Widget&& rhs); // 不存在类型推导， 所以是右值引用(注意rhs变量本身是左值)
};
 
template<typename T1>
class Gadget {
    ...
    template<typename T2>
    Gadget(T2&& rhs);// 需要类型推导 T2, 所以是万能引用
};
 
void f(Widget&& param); //不需要类型推导， 所以是右值引用
```
`Gadget`  构造函数当中的`rhs`  是一个万能引用, 所以它可能绑定到一个左值或者右值上，但是无论它被绑定到什么东西上，`rhs`  本身还是一个 左值。

如果它被绑定到一个右值并且我们想利用这个右值的 rvalueness， 我们就要重新将  `rhs`  转换回一个rvalue。如果它被绑定到一个左值上，当然我们就不想把它当做 右值。

**一个绑定到万能引用上的对象可能具有左值性或者右值性，正是因为有这种二义性，所以催生了`std::forward`**: 如果一个本身是 lvalue 的 universal reference 如果绑定在了一个 rvalue 上面，就把它重新转换为rvalue。函数的名字 (“`forward`”) 的意思就是，我们希望在传递参数的时候，**可以保存参数原来的lvalueness 或 rvalueness，即是说把参数转发给另一个函数**。

**特别注意, 下面这段代码， 其实是没有类型推导的:**
```cpp
template<typename T> 
void f(std::vector<T>&& param); //其实不需要类型推导， 所以是右值引用     
```

这里，我们同时有类型推导和一个带“`&&`”的参数，但是参数却不具有 “`T&&`” 的形式，而是 “`std::vector<t>&&`”。其结果就是，参数就只是一个**普通的rvalue reference**，而不是万能引用。 

**万能引用只以 “`T&&`”的形式出现！即便是仅仅加一个const限定符都会使得“`&&`”不再被解释为万能引用**:
```cpp
template<typename T>
void f(const T&& param);               // “&&” means rvalue reference
```

**有的时候你可以在函数模板的声明中看到`T&&`，但却没有发生类型推导**。来看下`std::vector`的  `push_back`  函数:[3]
```cpp
template <class T, class Allocator = allocator<T> >
class vector {
public:
    ...
    void push_back(T&& x); //其实类型是确定的 vector<T>, 所以是右值引用
};
```

这里,  `T`  是模板参数, 并且`push_back接受一个``T&&`, 但是**这个参数却不是万能引用**! 这怎么可能?

如果我们看看`push_back在类外部是如何声明的，这个问题的答案就很清楚了。`我会假装`std::vector`的  `Allocator`  参数不存在，因为它和我们的讨论无关。我们来看看没Allocator参数的`std::vector::push_back`:

template <class T> void vector<T>::push_back(T&& x);

`push_back`不能离开`std::vector<T>`这个类而独立存在。但如果我们有了一个叫做`std::vector<T>`的类，我们就已经知道了T是什么东西，那就没必要推导T。

举个例子可能会更好。如果我这么写:
```cpp
Widget makeWidget();
std::vector<Widget> vw;

Widget w;
vw.push_back(makeWidget());      // create Widget from factory, add it to vw
```
代码中对  `push_back`  的使用会让编译器实例化类  `std::vector<Widget>`  相应的函数。这个`push_back`  的声明看起来像这样:
```
void std::vector<Widget>::push_back(Widget&& x);
```

看到了没? 一旦我们知道了类是  `std::vector<Widget>`，`push_back`的参数类型就完全确定了: 就是`Widget&&`。这里完全不需要进行任何的类型推导。

对比下  `std::vector`  的`emplace_back`，它看起来是这样的:
```cpp
template <class T, class Allocator = allocator<T> >
class vector {
public:
    ...
    template <class... Args>
    void emplace_back(Args&&... args); // deduced parameter types ⇒ type deduction;
    ...                                // && ≡ universal references
};
```
`emplace_back`  看起来需要多个参数(Args和args的声明当中都有...)，但重点是每一个参数的类型都需要进行推导。函数的模板参数  `Args`  和类的模板参数`T`无关，所以即使我知道这个类具体是什么，比如说，`std::vector<Widget>`，但我们还是不知道`emplace_back`的参数类型是什么。

我们看下在类`std::vector<Widget>`外面声明的  `emplace_back`会更清楚的表明这一点 (我会继续忽略  `Allocator`  参数):
```cpp
template<class... Args>
void std::vector<Widget>::emplace_back(Args&&... args);
```

#### 4. 值类别(value category)和值类型(value type)
“值类别”（value category）和“值类型”（value type）是两个看似相 似、却毫不相干的术语。

**值类别**: 指的是上面这些**左值、右值相关的概念**。
**值类型**: 是与引用类型（reference type）相对而言，**表明一个变量是代表实际数值，还是引用另外一个数值**。

>在C++ 里，所有的原生类型、枚举、结构、联合、类都代表值类型，只有引用（&）和指针（*）才是引用类型。\
>在 Java 里，数字等原生类型是值类型，类则属于引用类型。\
>在Python 里，一切类型都是引用类型。

**一个表达式的左值性(lvalueness)或者右值性(rvalueness)和它的类型无关。**

来看下  `int`。可以有lvalue的`int`  (e.g., 声明为int的变量)，还有rvalue的`int`  (e.g., 字面值`10`)。用户定义类型`Widget`等等也是一样的。

一个`Widget`对象可以是lvalue(e.g., a  `Widget`  变量) 或者是rvalue (e.g., 创建`Widget的`工程函数的返回值)。

**表达式的类型不会告诉你它到底是个左值还是右值**。因为表达式的左值或 右值 独立于它的类型，我们就可以有一个 左值，但它的类型确却是右值引用，也可以有一个 右值引用 类型的右值 :
```
Widget makeWidget(); // factory function for Widget 
Widget&& var1 = makeWidget() // var1 is an lvalue, but
							// its type is rvalue reference (to Widget) 
Widget var2 = static_cast<Widget&&>(var1); // the cast expression yields an rvalue, but
                                           // its type is rvalue reference  (to Widget)
```
`var1`类别是左值，但它的类型是右值引用。`static_cast<Widget&&>(var1)`表达式是个右值，但它的类型是右值引用。

把 lvalues (例如  `var1`) 转换成 rvalues 比较常规的方式是对它们调用`std::move`，所以  `var2`  可以像这样定义:
```c
Widget var2 = std::move(var1);             // equivalent to above
```

我最初的代码里使用  `static_cast`  仅仅是为了显示的说明这个表达式的类型是个rvalue reference (`Widget&&`)。rvalue reference 类型的具名变量和参数是 lvalues。(你可以对他们取地址。)

**std::move() 只是把左值转换成右值， 不会调用移动构造函数。 但是static_cast<Widget&&>(var1) 会调用移动构造函数**（如果没有定义， 则会调用拷贝构造函数） 构造一个临时对象， 然后赋给 var2. 比如下面的例子:
```cpp
#include <iostream>
using namespace std;

class Widget {
public:
        Widget() {
                cout << "The default constructor is called" << endl;
        }
        Widget(Widget &w) {
                cout << "The copy constructor is called" << endl;
        }

        Widget(Widget &&w) {
                cout << "The move constructor is called" << endl;
        }

        ~Widget(){
                cout << "The destructor is called" << endl;
        }
};

int main() {
        Widget w1, w11;
        Widget &w2 = w1;
        Widget &&w3 = move(w1);
        Widget w4 = static_cast<Widget&&>(w11);
        Widget w5 = move(w3);
        Widget &&w6 = move(w11);
        Widget w7 = w1;
        return 0;
}
```
输出结果:
```cpp
The default constructor is called  // w1 默认构造函数构造
The default constructor is called // w11 默认构造函数构造
The move constructor is called // Widget w4 = static_cast<Widget&&>(w11), 移动构造函数被调用
The move constructor is called // Widget w5 = move(w3), 调用移动构造函数构造对象。
The copy constructor is called // Widget w7 = w1 调用拷贝构造函数。
The destructor is called
The destructor is called
The destructor is called
The destructor is called
The destructor is called
```

#### 5. 左值引用的使用场景和实际意义: 避免内存的拷贝， 节省内存， 提高效率。
- 当**引用作为参数**的时候，其效果跟利用指针作为参数的效果相当。当调用函数时，函数中的形参就会被当成实参变量或者对象的一个别名使用，也就是说**函数中对形参的各种操作实际上就是对实参本身的操作**，而非简单的实参变量或者对象的值拷贝给形参
```
void func1(string s)
{...}

void func2(const string& s)
{...}


int main()
{
    string s1("Hello World!");
    func1(s1);  // 由于是传值传参且做的是深拷贝，代价较大
    func2(s1);  // 左值引用做参数减少了拷贝，提高了效率    
                //通常函数调用时采用值传递的方式，系统会在内存中开辟空间用来存储形参变量，并将实参变量的值拷贝给形参变量，所以形参变量只是实参变量的副本而已，并且如果函数传递的是类的对象，系统还会调用类中的拷贝构造函数来构造形参对象    
                //使用引用作为参数传递时，由于此时形参只是传递函数的实参变量或者对象的别名而非副本，故系统不会耗费时间在内存中开辟空间来存储形参，因此如果参数传递的数据较大，建议使用引用作为函数的形参，提高函数的时间效率，节省内存空间    
                //指针作为函数的形参，虽然达到的效果跟使用引用一样，但当调用函数时仍然需要为形参指针分配空间，引用则不需要【引用在底层也会分配指针大小的空间，在汇编底层角度，引用和指针是一样的，不过引用类似于常量指针】。
                //推荐使用引用而非指针作为函数的传递函数
    return 0;
}
```
- 左值引用**做返回值**（仅限于对象出了函数作用域以后还存在的情况）
```c
string s2("hello"); 
// string operator+=(char ch) 传值返回存在拷贝且是深拷贝 
// string& operator+=(char ch) 左值引用做返回值没有拷贝，提高了效率
s2 += '!';
```
- **左值引用的不足**: 
当对象（对象是函数内的局部对象）出了函数作用域以后不存在时，就不可以使用左值引用返回了。
```c
string operator+(const string& s, char ch)
{
	string ret(s);
	ret.push_back(ch);
	return ret;
}

// 拿现在这个函数来举例：ret是函数内的局部对象，出了函数作用域后会被析构，即被销毁了
// 若此时再返回它的别名（左值引用），也就是再拿这个对象来用，就会出问题

/*
①：不能返回局部变量的引用。局部变量会在函数返回后被销毁，此时对 局部变量的引用就会成为“无所指”的引用，程序会进入未知状态。
②：不能返回函数内部通过 new 分配的内存的引用。虽然不存在局部变量的被动销毁问题，但如果被返回的函数的引用只是作为一个临时变量出现，而没有将其赋值给一个实际的变量，    那么就可能造成这个引用所指向的空间（有 new 分配）无法释放的情况（由于没有具体的变量名，故无法用 delete 手动释放该内存），从而造成内存泄漏。
*/
```
于是，对于**第二种情形**，左值引用也无能为力，只能传值返回

#### 6. 右值引用的使用场景和实际意义:  为了解决上述传值返回的拷贝问题，C++11标准就增加了右值引用和移动语义。
-  **返回函数的局部变量**

为了方便对临时对象的使用，C++ 对临时对象有特殊的生命周期延长规则。这条规则是：**如果一个 局部变量 被绑定到一个引用上，它的生命周期则会延长到跟这个引用变量一样长**

```c
QList<Pin*> getModelPins() const
{
    QList<Pin*> pins;
    for (auto& pin : m_lstPins) {
        pins << pin.data();
    }
    return std::move(pins);
}

//-->>调用

QList<Pin*> getInstModelPins(std::string instId) const
{
    auto inst = d->getInst(instId);
    if (inst) {
        auto pins = inst->getModelPins();
        return std::move(pins);
    }
    return QList<Pin*>();
}
```

-  **C++11标准的STL 容器接口**
除了上面的使用场景之外，C++11标准的STL 容器的相关接口函数也增加了右值引用版本
![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201151655274-574842866.png)

#### 7.   **引用折叠**
这个问题的核心是，C++11当中的一些构造会弄出来引用的引用，而**C++不允许出现引用的引用**。如果代码当中显式的出现了一个引用的引用，那代码就是不合法的:

```cpp
Widget w1;
...
Widget& & w2 = w1;// error! No such thing as “reference to reference”
```

但是，有些情况下，在你对类型进行操作的时候可能会搞出来引用的引用，编译器如果对这种情况报错是不对的。我们从C++98/C++03标准的时候就知道这件事了。

- 在对一个 **万能引用 的模板参数**进行类型推导时候，同一个类型的 lvalues 和 rvalues 被推导为稍微有些不同的类型。具体来说，**类型T的左值被推导为T&**(i.e., lvalue reference to  `T`)，而**类型T的 右值被推导为  `T。`**(注意，虽然 lvalue 会被推导为lvalue reference，但 rvalues 却不会被推导为 rvalue references!) 我们来看下分别用rvalue和lvalue来调用一个接受universal reference的模板函数时会发生什么:

```cpp
template<typename T>
void f(T&& param); 
... 
int x; 
... 
f(10);                           // invoke f on rvalue
f(x);                            // invoke f on lvalue
```

当用rvalue 10调用 f 的时候, T被推导为 int，实例化的 f 看起来像这样:

```cpp
void f(int&& param);             // f instantiated from rvalue
```

这里一切都OK。但是当我们用lvalue x 来调用 f 的时候，T 被推导为int&，而实例化的 f 就包含了一个引用的引用:

```cpp
void f(int& && param);           // initial instantiation of f with lvalue
```

因为这里出现了引用的引用，这实例化的代码乍一看好像不合法，但是像– “`f(x)`” –这么写代码是完全合理的。为了避免编译器对这个代码报错，**C++11引入了一个叫做“引用折叠”(reference collapsing)的规则来处理某些像模板实例化这种情况下带来的"引用的引用"的问题**。

因为有两种类型的引用 (lvalue references 和 rvalue references)，那"引用的引用"就有四种可能的组合: lvalue reference to lvalue reference, lvalue reference to rvalue reference, rvalue reference to lvalue reference, 以及 rvalue reference to rvalue reference。

引用折叠只有两条规则:
-   **一个 rvalue reference to an rvalue reference 会变成 (“折叠为”) 一个 rvalue reference**.
-   **所有其他种类的"引用的引用" (i.e., 组合当中含有lvalue reference) 都会折叠为 lvalue reference**.

在用lvalue实例化 f 时，应用这两条规则，会生成下面的合法代码，编译器就是这样处理这个函数调用的:

```cpp
void f(int& param); // instantiation of f with lvalue after reference collapsing
```

上面的内容精确的说明了一个万能引用是如何在经过类型推导和引用折叠之后，可以变为一个 lvalue reference的。实际上，universal reference 其实只是一个身处于引用折叠背景下的rvalue reference。

**当一个变量本身的类型是引用类型的时候，这里就有点难搞了。这种情况下，类型当中所带的引用就被忽略了**。例如:

```cpp
int x; 
... 
int&& r1 = 10; // r1’s type is int&& 
int& r2 = x; // r2’s type is int&
```

在调用模板函数  `f`  的时候  `r1`  `和 r2`  的类型都被当做 int。这个扒掉引用的行为，和"universal references 在类型推导期间，lvalues 被推导为  `T&`  ，rvalues 被推导为"T" 这条规则无关。所以，这么调用模板函数的时候:

```cpp
template<typename T>
void f(T &&param) {
    static_assert(std::is_lvalue_reference<T>::value, "T& is lvalue reference");
    cout << "T& is lvalue reference" << endl;
}

int main() {
    int x;
    int &&r1 = 10;
    int &r2 = x;
    f(r1);
    f(r2);
}

```

`r1`  和`r2`  的类型都被推导为  `int&`。这是为啥呢?

首先，`r1`  和  `r2`  的引用部分被去掉了(留下的只是 int)。然后，因为它们都是 lvalues 所以当调用 f，对 universal reference 参数进行类型推导的时候，得到的类型都是int&。

- 我前面已经说过，**引用折叠只发生在“像是模板实例化这样的场景当中”。 声明`auto`变量是另一个这样的场景**。推导一个universal reference的  `auto`  变量的类型，在本质上和推导universal reference的函数模板参数是一样的，所以类型  `T`  的lvalue被推导为  `T&`，类型 T 的rvalue被推导为  `T`。我们再来看一下本文开头的实例代码:

```cpp
Widget&& var1 = someWidget; // var1 is of type Widget&& (no use of auto here) 
auto&& var2 = var1; // var2 is of type Widget& (see below)
```

`var1`  的类型是  `Widget&&`，但是它的 reference-ness 在推导  `var2`  类型的时候被忽略了;`var1`  这时候就被当做 Widget。

因为它是个lvalue，所以初始化一个`universal reference`(`var2`)的时候，`var1`  的类型就被推导成`Widget&`。在  `var2`  的定义当中将 auto 替换成`Widget&`  会生成下面的非法代码:

```cpp
Widget& && var2 = var1;          // note reference-to-reference
```

而在引用折叠之后，就变成了:

```cpp
Widget& var2 = var1;             // var2 is of type Widget&
```

- 还有第三种发生引用折叠的场景，就是**形成和使用  `typedef`  的时候**。看一下这样一个类模板，

```cpp
template<typename T>
class Widget {
    typedef T& LvalueRefType;
    ...
};
int main() {
    Widget<int&> w;
}
```

根据引用折叠的规则：

-   一个 rvalue reference to an rvalue reference 会变成 (“折叠为”) 一个 rvalue reference.
-   所有其他种类的"引用的引用" (i.e., 组合当中含有lvalue reference) 都会折叠为 lvalue reference.

我们知道T会被推导为lvalue reference，因此结果肯定是lvalue reference,对应于上述规则，我们来通过代码验证。

```cpp
template<typename T>
class Widget {
    typedef T& LvalueRefType;
    typedef T&& RvalueRefType;
public:
    void judge() {
        static_assert(std::is_lvalue_reference<LvalueRefType>::value, "LvalueRefType & is lvalue reference");
        static_assert(std::is_lvalue_reference<RvalueRefType>::value, "RvalueRefType & is lvalue reference");
        cout << "LvalueRefType and RvalueRefType is lvalue reference" << endl;
    }
};
int main() {
    Widget<int&> w;
}
```

输出：

```cpp
LvalueRefType and RvalueRefType is lvalue reference
```

如果我们在应用引用的上下文中使用这个typedef，例如:

```text
void f(Widget<int&>::LvalueRefType&& param);
```

在对  `typedef`  扩展之后会产生非法代码:

```cpp
void f(int& && param);
```

但引用折叠这时候又插了一脚进来，所以最终的声明会是这样:

```cpp
void f(int& param);
```

- 最后还有一种场景会有引用折叠发生，就是**使用  `decltype`**。和模板和  `auto`  一样，`decltype`  对表达式进行类型推导时候可能会返回  `T`  或者  `T&`，然后`decltype`  会应用 C++11 的引用折叠规则。

好吧，  `decltype`  的类型推导规则其实和模板或者  `auto`  的类型推导不一样。这里的细节过于晦涩，所以就放在  [Further Information section](https://link.zhihu.com/?target=http%3A//isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers%23FurtherInformation)  里讲解，但是我们需要注意这样一个区别，即  `decltype`  对一个具名的、非引用类型的变量，会推导为类型  `T`  (i.e., 一个非引用类型)，在相同条件下，`模板`和  `auto`  却会推导出  `T&`。

还有一个重要的区别就是`decltype`  进行类型推导只依赖于  `decltype`  的表达式; 用来对变量进行初始化的表达式的类型(如果有的话)会被忽略。因此:

```cpp
Widget w1, w2; 
auto&& v1 = w1;   
decltype(w1)&& v2 = w2; 
```

v1本身是左值，根据`auto&&`知道为万能引用，因此v1被推导为指向w1的左值引用。

w2是左值，`decltype(w1)`推导为`Widget`，因此v2为右值引用，根据右值引用只能绑定到右值，这里却给了一个左值，因此不能编译！

#### 8.  移动语义
移动语义是 C++11 中新增的一个语言特性，它允许将**一个对象的所有权从一个对象转移到另一个对象，而不需要进行数据的拷贝**。这种转移可以在对象生命周期的任意时刻进行，可以说是一种轻量级的复制操作。移动语义是通过右值引用来实现的。

移动语义使编译器有可能**用廉价的移动操作来代替昂贵的拷贝操作**。正如拷贝构造函数和拷贝赋值操作符给了你控制拷贝语义的权力，**移动构造函数和移动赋值操作符也给了你控制移动语义的权力**。移动语义也允许创建只可移动（_move-only_）的类型，例如`std::unique_ptr`，`std::future`和`std::thread`

将一个对象中的资源移动到另一个对象（资源控制权的转移）
#### 1)  **移动构造函数**: 转移参数右值的资源来构造自己
```cpp
// 这是一个模拟string类的实现的移动构造
string(string&& s):_str(nullptr), _size(0), _capacity(0)
{
	swap(s);
}
```
**拷贝构造函数**和**移动构造函数**都是构造函数的重载函数，所不同的是：

-   拷贝构造函数的参数是  **const左值引用，接收左值或右值**；
-   移动构造函数的参数是**右值引用，接收右值或被 move 的左值**。

> 当传来的参数是右值时，虽然拷贝构造函数可以接收，但是编译器会认为移动构造函数更加匹配，就会调用移动构造函数。

总的来说，如果这两个函数都有在类内定义的话，在构造对象时：

-   若是**左值做参数**，那么就会调用拷贝构造函数，做一次**拷贝**（如果是像 string 这样的在堆空间上存在资源的类，那么**每调用一次拷贝构造就会做一次深拷贝**）。
-   若是**右值做参数**，那么就会调用移动构造，而调用移动构造就会**减少拷贝**（如果是像 string 这样的在堆空间上存在资源的类，那么**每调用一次移动构造就会少做一次深拷贝**）。

比如执行下面这几行代码：
```c
string s("Hello World11111111111111111"); 
string s1 = s; // s是左值，所以调用拷贝构造函数
string s2 = move(s); // s被move后变为右值，所以调用移动构造函数，s的资源会被转移用来构造s2 
					// 要注意的是，move一般是不这样用的，因为s的资源被转走了
```
![执行前后内存情况:](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201143849477-1773655910.png)

**移动构造函数有无的区别**: 
比如执行语句 cout << MyLib::to_string(1234) << endl;
- **只有拷贝构造，没有移动构造**

![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201144808042-640790079.png)

**在 to_string 函数栈帧销毁前，用局部对象 str  拷贝构造出临时对象返回到函数调用处【此时str也被成为将亡值，返回的是右值】**

![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201144921741-1784150596.png)

- **既有拷贝构造， 又有移动构造**

![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201145058159-1898728599.png)

**在 to_string 函数栈帧销毁前，用局部对象 str （反正 str 要销毁，将 str 视为右值，直接转移 str 的资源 ）移动构造出临时对象返回到函数调用处**

![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201145212017-1609779550.png)

**编译器一般会做一些优化**:
比如执行语句MyLib::string ret = MyLib::to_string(1234); 

- 只有拷贝构造， 没有移动构造

![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201145342848-1222428997.png)

**因为临时对象有 ret 来接收，这样的话临时对象的创建和销毁就显得多余了，不如省略掉这一步，直接用 str 拷贝构造出 ret**

![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201145452232-1002914911.png)

- 既有拷贝构造， 又有移动构造

![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201145714218-1241979520.png)

**因为临时对象有 ret 来接收，先拷贝构造出临时对象再用它移动构造出 ret ，临时对象好像没必要产生一样，不如省略掉。既然 str 是 to_string 函数栈帧的局部对象，最后还是要销毁，不如将 str 视为右值，直接转移 str 的资源用来构造 ret ，也就是直接用 str 移动构造出 ret**

![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201145845475-711590615.png)

#### 2) **移动赋值**和移动构造类似.
```cpp
// 这是一个模拟string类的实现的移动赋值
string& operator=(string&& s)
{
　　swap(s);
　　return *this;
}
```

下面是一个完整的自定类的移动构造函数h和移动赋值运算法符:

```cpp
// Move constructor.
MemoryBlock(MemoryBlock&& other) noexcept
   : _data(nullptr)
   , _length(0)
{
   std::cout << "In MemoryBlock(MemoryBlock&&). length = "
             << other._length << ". Moving resource." << std::endl;

   // Copy the data pointer and its length from the
   // source object.
   _data = other._data;
   _length = other._length;

   // Release the data pointer from the source object so that
   // the destructor does not free the memory multiple times.
   other._data = nullptr;
   other._length = 0;
}

// Move assignment operator.
MemoryBlock& operator=(MemoryBlock&& other) noexcept
{
   std::cout << "In operator=(MemoryBlock&&). length = "
             << other._length << "." << std::endl;

   if (this != &other)
   {
      // Free the existing resource.
      delete[] _data;

      // Copy the data pointer and its length from the
      // source object.
      _data = other._data;
      _length = other._length;

      // Release the data pointer from the source object so that
      // the destructor does not free the memory multiple times.
      other._data = nullptr;
      other._length = 0;
   }
   return *this;
}

```

#### 3) std::move() 函数
-   std::move作用主要可以将一个**左值转换成右值引用**，从而可以调用C++11右值引用的移动构造函数
-   std::move应该是针对你的对象中有在**堆上分配内存**这种情况而设置的。
- 若对一个对象做move操作，就不要声明为 const. 因为对const对象的move请求会执行到copy操作上

```
// move example
#include <utility>      // std::move
#include <iostream>     // std::cout
#include <vector>       // std::vector
#include <string>       // std::string

int main () {
  std::string foo = "foo-string";
  std::string bar = "bar-string";
  std::vector<std::string> myvector;

  myvector.push_back (foo); // 拷贝构造
  myvector.push_back (std::move(bar)); // 移动构造

  std::cout << "myvector contains:";
  for (std::string& x:myvector) 
	  std::cout << ' ' << x;
  std::cout << '\n';

  return 0;
}
```
又一个例子：
```cpp
include <iostream>
using namespace std;

class Widget {
public:
	Widget() {
		cout << "The default constructor is called" << endl;
	}
	Widget(Widget &w) {
		cout << "The copy constructor is called" << endl;
	}

	Widget(Widget &&w) {
		cout << "The move constructor is called" << endl;
	}

	~Widget(){
		cout << "The destructor is called" << endl;
	}
};

int main() {
	Widget w1;
	Widget w2 = move(w1); // 移动构造函数会被调用
	return 0;
}
```


在分析std::move()源代码之前， 首先看remove_reference 的源码:
`remove_reference`的作用是去除`T`中的引用部分，只获取其中的类型部分。无论`T`是左值还是右值，最后**只获取它的类型部分**。
```c
template<typename _Tp> struct remove_reference
{ 
	typedef _Tp   type; 
};
 
// 特化版本
template<typename _Tp> struct remove_reference<_Tp&>
{ 
	typedef _Tp   type; 
};
 
template<typename _Tp> struct remove_reference<_Tp&&>
{ 
	typedef _Tp   type; 
};
```
`std::move()` 源码:
```c
// FUNCTION TEMPLATE move
template <class _Ty> _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept 
{ // forward _Arg as movable
    return static_cast<remove_reference_t<_Ty>&&>(_Arg);
}
```
std::move的功能是：

-   **传递的是左值**，推导为左值引用，仍旧static_cast**转换为右值引用**。    
-   **传递的是右值**，推导为右值引用，仍旧static_cast**转换为右值引用**。    
-   在返回处，直接范围右值引用类型即可。还是通过renive_reference获得_Tp类型，然后直接type&&即可。

所以std::remove_reference<_Tp>::type&&，就是一个右值引用，我们就知道了std::move干的事情了。

事实上，右值只不过**经常**是移动操作的候选者。假设你有一个类，它用来表示一段注解。这个类的构造函数接受一个包含有注解的`std::string`作为形参，然后它复制该形参到数据成员。假设你了解[Item41](https://cntransgroup.github.io/EffectiveModernCppChinese/8.Tweaks/item41.html)，你声明一个值传递的形参：

`class Annotation {
public:
    explicit Annotation(std::string text);  //将会被复制的形参，
    …                                       //如同条款41所说，
};                                          //值传递` 

但是`Annotation`类的构造函数仅仅是需要读取`text`的值，它并不需要修改它。为了和历史悠久的传统：能使用`const`就使用`const`保持一致，你修订了你的声明以使`text`变成`const`：

`class Annotation {
public:
    explicit Annotation(const std::string text);
    …
};` 

当复制`text`到一个数据成员的时候，为了避免一次复制操作的代价，把`std::move`应用到`text`上，因此产生一个右值：

```cpp
class Annotation {
public:
    explicit Annotation(const std::string text)
    ：value(std::move(text))    //“移动”text到value里；这段代码执行起来 { … }                       //并不是看起来那样
    
    …

private:
    std::string value;
};
```

这段代码可以编译，可以链接，可以运行。这段代码将数据成员`value`设置为`text`的值。这段代码与你期望中的完美实现的唯一区别，是`text`并不是被移动到`value`，而是被**拷贝**。诚然，`text`通过`std::move`被转换到右值，但是`text`被声明为`const std::string`，所以在转换之前，`text`是一个左值的`const std::string`，而转换的结果是一个右值的`const std::string`，但是纵观全程，`const`属性一直保留。

当编译器决定哪一个`std::string`的构造函数被调用时，考虑它的作用，将会有两种可能性：
```cpp
class string {                  //std::string事实上是
public:                         //std::basic_string<char>的类型别名
    …
    string(const string& rhs);  //拷贝构造函数
    string(string&& rhs);       //移动构造函数
    …
};
```

在类`Annotation`的构造函数的成员初始化列表中，`std::move(text)`的结果是一个`const std::string`的右值。这个右值不能被传递给`std::string`的移动构造函数，因为移动构造函数只接受一个指向**non-`const`**的`std::string`的右值引用。然而，该右值却可以被传递给`std::string`的拷贝构造函数，因为lvalue-reference-to-`const`允许被绑定到一个`const`右值上。因此，`std::string`在成员初始化的过程中调用了**拷贝**构造函数，即使`text`已经被转换成了右值。这样是为了确保维持`const`属性的正确性。从一个对象中移动出某个值通常代表着修改该对象，所以语言不允许`const`对象被传递给可以修改他们的函数（例如移动构造函数）。

从这个例子中，可以总结出两点。第一，**不要在你希望能移动对象的时候，声明他们为`const`。对`const`对象的移动请求会悄无声息的被转化为拷贝操作。第二点，`std::move`不仅不移动任何东西，而且它也不保证它执行转换的对象可以被移动**。关于`std::move`，你能确保的唯一一件事就是将它应用到一个对象上，你能够得到一个右值。


#### 9.  转发(forwarding)
对于  `template <typename T> foo(T&&)`这样的代码。

-   如果传递过去的参数是左值，T 的推导结果是左值引用，那 T&& 的结果仍然是左值引用——即 T& && 坍缩成了T&
-   如果传递过去的参数是右值，T 的推导结果是参数的类型本身。那 T&& 的结果自然就是一个右值引用。

例如：

```cpp
void foo(const shape&)
{
	puts("foo(const shape&)");
}
void foo(shape&&)
{
	puts("foo(shape&&)");
}
void bar(const shape& s)
{
	puts("bar(const shape&)");
	foo(s);
}
void bar(shape&& s)
{
	puts("bar(shape&&)");
	foo(s);
}
int main()
{
	bar(circle());
}
```

输出：

```cpp
bar(shape&&)
foo(const shape&）
```

bar中传入的是右值，调用bar的`&&`重载函数，但是对于`void bar(shape&& s)`来说，s本身是一个lvalue，所以在foo(s)后，仍旧调用的是`&`重载函数。

如果想要调用`foo(shape&&)`，可以：

```cpp
foo(std::move(s))
```

或者：

```cpp
foo(static_cast<shape&&>(s)
```

再考虑下面这个例子：

```cpp
void foo(const shape&)
{
	puts("foo(const shape&)");
}
void foo(shape&&)
{
	puts("foo(shape&&)");
}
template <typename T>
void bar(T&& s)
{
	foo(std::forward<T>(s));
}
int main() {
    circle temp;
    bar(temp);
    bar(circle());
}
```

输出：

```cpp
foo(const shape&)
foo(shape&&)

```

上面提到过**一个绑定到universal reference上的对象可能具有 lvalueness 或者 rvalueness，正是因为有这种二义性**,所以催生了`std::forwar()`: 如果一个本身是 lvalue 的 universal reference 如果绑定在了一个 rvalue 上面，就把它重新转换为rvalue。函数的名字 (“`forward`”) 的意思就是，我们希**望在传递参数的时候，可以保存参数原来的lvalueness 或 rvalueness，即是说把参数转发给另一个函数**。

在分析``std::forward()`之前，先看看`remove_reference`，下面是`remove_reference`的实现：

```cpp
template<typename _Tp>
struct remove_reference
{ typedef _Tp   type; };

// 特化版本
template<typename _Tp>
struct remove_reference<_Tp&>
{ typedef _Tp   type; };

template<typename _Tp>
struct remove_reference<_Tp&&>
{ typedef _Tp   type; };
```

`remove_reference`的作用是去除`T`中的引用部分，只获取其中的类型部分。无论`T`是左值还是右值，最后只获取它的类型部分。

> std::forward源码剖析

-   转发左值
```cpp
template<typename _Tp> constexpr _Tp&& forward(typename 
	std::remove_reference<_Tp>::type& __t) noexcept
{ 
	return static_cast<_Tp&&>(__t); 
}
```

先获得类型type，定义`_t`为左值引用的左值变量，通过`static_cast`进行强制转换。`_Tp&&`会发生引用折叠，当`_Tp`推导为左值引用，则折叠为`_Tp& &&`，即`_Tp&`，推导为右值引用，则为本身`_Tp&&`,所以`froward`返回值与`static_cast`处都为`_Tp&&`。

-   转发右值
```cpp
template<typename _Tp>
constexpr _Tp&&
forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
{
  static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
        " substituting _Tp is an lvalue reference type");
  return static_cast<_Tp&&>(__t);
}
```

与`std::move`总是**无条件**的将它的实参为右值不同，`std::forward`只有在满足一定条件的情况下才执行转换。`std::forward`是**有条件**的转换。要明白什么时候它执行转换，什么时候不，想想`std::forward`的典型用法。最常见的情景是一个模板函数，接收一个万能引用形参，并将它传递给另外的函数：
```cpp
void process(const Widget& lvalArg); //处理左值
void process(Widget&& rvalArg); //处理右值

template<typename T> //用以转发param到process的模板
void logAndProcess(T&& param) {
    auto now =                              //获取现在时间
        std::chrono::system_clock::now();
    
    makeLogEntry("Calling 'process'", now);
    process(std::forward<T>(param));
}
``` 

考虑两次对`logAndProcess`的调用，一次左值为实参，一次右值为实参：
```cpp
Widget w;

logAndProcess(w);               //用左值调用
logAndProcess(std::move(w));    //用右值调用
```

在`logAndProcess`函数的内部，形参`param`被传递给函数`process`。函数`process`分别对左值和右值做了重载。当我们使用左值来调用`logAndProcess`时，自然我们期望该左值被当作左值转发给`process`函数，而当我们使用右值来调用`logAndProcess`函数时，我们期望`process`函数的右值重载版本被调用。

但是`param`，正如所有的其他函数形参一样，是一个左值。每次在函数`logAndProcess`内部对函数`process`的调用，都会因此调用函数`process`的左值重载版本。为防如此，我们需要一种机制：**当且仅当传递给函数`logAndProcess`的用以初始化`param`的实参是一个右值时，`param`会被转换为一个右值。这就是`std::forward`做的事情**。这就是为什么`std::forward`是一个**有条件**的转换：它的实参用右值初始化时，转换为一个右值。

你也许会想知道`std::forward`是怎么知道它的实参是否是被一个右值初始化的。举个例子，在上述代码中，`std::forward`是怎么分辨`param`是被一个左值还是右值初始化的？ 简短的说，该信息藏在函数`logAndProcess`的模板参数`T`中。该参数被传递给了函数`std::forward`，它解开了含在其中的信息。

考虑到`std::move`和`std::forward`都可以归结于转换，它们唯一的区别就是**std::move总是执行转换，而std::forward偶尔为之**。你可能会问是否我们可以免于使用`std::move`而在任何地方只使用`std::forward`。 从纯技术的角度，答案是yes：`std::forward`是可以完全胜任，`std::move`并非必须。当然，其实两者中没有哪一个函数是**真的必须**的，因为我们可以到处直接写转换代码，但是我希望我们能同意：这将相当的，嗯，让人恶心。

`std::move`的吸引力在于它的便利性：减少了出错的可能性，增加了代码的清晰程度。考虑一个类，我们希望统计有多少次移动构造函数被调用了。我们只需要一个`static`的计数器，它会在移动构造的时候自增。假设在这个类中，唯一一个非静态的数据成员是`std::string`，一种经典的移动构造函数（即，使用`std::move`）可以被实现如下：
```cpp
class Widget {
public:
    Widget(Widget&& rhs)
    : s(std::move(rhs.s))
    { ++moveCtorCalls; }

    …

private:
    static std::size_t moveCtorCalls;
    std::string s;
};
``` 

如果要用`std::forward`来达成同样的效果，代码可能会看起来像：
```cpp
class Widget{
public:
    Widget(Widget&& rhs) //不自然，不合理的实现
    : s(std::forward<std::string>(rhs.s))
    { ++moveCtorCalls; }

    …

}
```

注意，第一，`std::move`只需要一个函数实参（`rhs.s`），而`std::forward`不但需要一个函数实参（`rhs.s`），还需要一个模板类型实参`std::string`。其次，我们传递给`std::forward`的类型应当是一个non-reference，因为惯例是传递的实参应该是一个右值。同样，这意味着`std::move`比起`std::forward`来说需要打更少的字，并且免去了传递一个表示我们正在传递一个右值的类型实参。同样，它根绝了我们传递错误类型的可能性（例如，`std::string&`可能导致数据成员`s`被复制而不是被移动构造）。

更重要的是，`std::move`的使用代表着无条件向右值的转换，而使用`std::forward`只对绑定了右值的引用进行到右值转换。这是两种完全不同的动作。前者是典型地为了移动操作，而后者只是传递（亦为转发）一个对象到另外一个函数，保留它原有的左值属性或右值属性。因为这些动作实在是差异太大，所以我们拥有两个不同的函数（以及函数名）来区分这些动作。

**请记住：**

-   `std::move`执行到右值的无条件的转换，但就自身而言，它不移动任何东西。
-   `std::forward`只有当它的参数被绑定到一个右值时，才将参数转换为右值。
-   `std::move`和`std::forward`在运行期什么也不做。
#### 10. 小结：

-   在《Effective Modern C++》中建议：**对于右值引用使用std::move，对于万能引用使用std::forward。**
-   std::move()与std::forward()都仅仅做了类型转换而已。真正的移动操作是在移动构造函数或者移动赋值操作符中发生的。
-   `std::move()`可以应用于左值(普通的变量int这些使用move与不使用move效果一样)，但这么做要谨慎。因为一旦“移动”了左值，就表示当前的值不再需要了，如果后续使用了该值，产生的行为是未定义。
不同于转发左值，`_t`为右值引用的左值变量，除此之外中间加了一个断言，表示当不是左值的时候，也就是右值，才进行`static_cast`转换。


最后给个练手的例子[5]：

```cpp
void overloaded( int const &arg ) { std::cout << "by lvalue\n"; }
void overloaded( int && arg ) { std::cout << "by rvalue\n"; }

template< typename t >
/* "t &&" with "t" being template param is special, and  adjusts "t" to be
   (for example) "int &" or non-ref "int" so std::forward knows what to do. */
void forwarding( t && arg ) {
    std::cout << "via std::forward: ";
    overloaded( std::forward< t >( arg ) );
    std::cout << "via std::move: ";
    overloaded( std::move( arg ) ); // conceptually this would invalidate arg
    std::cout << "by simple passing: ";
    overloaded( arg );
}

int main() {
    std::cout << "initial caller passes rvalue:\n";
    forwarding( 5 );
    std::cout << "initial caller passes lvalue:\n";
    int x = 5;
    forwarding( x );
}

```

输出：

```cpp
initial caller passes rvalue:
via std::forward: by rvalue
via std::move: by rvalue
by simple passing: by lvalue
initial caller passes lvalue:
via std::forward: by lvalue
via std::move: by rvalue
by simple passing: by lvalue
```
-  **不要返回本地变量的引用， 返回本地局部变量不要用std::move()**

**C++ 编程错误，是在函数里返回一个本地对象的引用**。由于在函数结束时本地对象即被销毁，返回一个指向本地对象的引用属于未定义行为。

在 C++11 之前，返回一个本地对象意味着这个对象会被拷贝，除非编译器发现可以做返回值优化（named return value optimization，或 NRVO），能把对象直接构造到调用者的栈上。从 C++11 开始，返回值优化仍可以发生，但在没有返回值优化的情况下，**编译器将试图把本地对象移动出去，而不是拷贝出去**。**这一行为不需要程序员手工用 std::move 进行干预——使用std::move 对于移动行为没有帮助，反而会影响返回值优化**。

例如：

```cpp
#include <iostream> // std::cout/endl
#include <utility> // std::move
using namespace std;
class Obj {
public:
    Obj()
    {
        cout << "Obj()" << endl;
    }
    Obj(const Obj&)
    {
        cout << "Obj(const Obj&)"
             << endl;
    }
    Obj(Obj&&)
    {
        cout << "Obj(Obj&&)" << endl;
    }
};
Obj simple()
{
    Obj obj;
// 简单返回对象；一般有返回值优化。 同一个对象obj 会被返回。
    cout << &obj << endl;
    return obj;
}
Obj simple_with_move()
{
    Obj obj;
// move 会禁止返回值优化。 新的对象会被ceate出来返回。 调用移动构造函数无需拷贝。
    cout << &obj << endl;
    return std::move(obj);
}
Obj complicated(int n)
{
    Obj obj1;
    Obj obj2;
    // 有分支，一般无返回值优化。新的对象会被ceate出来返回。 调用移动构造函数无需拷贝。
    if (n % 2 == 0) {
        cout << &obj1 << endl;
        return obj1;
    } else {
        cout << &obj2 << endl;
        return obj2;
    }
}
int main()
{
    cout << "*** 1 ***" << endl;
    auto obj1 = simple();
    cout << &obj1 << endl;
    cout << "*** 2 ***" << endl;
    auto obj2 = simple_with_move();
    cout << &obj2 << endl;
    cout << "*** 3 ***" << endl;
    auto obj3 = complicated(42);
    cout << &obj3 << endl;
}
```

输出：

```cpp
*** 1 ***
Obj()
0x7ffe4fe7e035
0x7ffe4fe7e035
*** 2 ***
Obj()
0x7ffe4fe7e017
Obj(Obj&&)
0x7ffe4fe7e036
*** 3 ***
Obj()
Obj()
0x7ffe4fe7e016
Obj(Obj&&)
0x7ffe4fe7e037
```
## **总结**

（1）在类型声明当中， “&&” 要不就是一个 rvalue reference ，要不就是一个  _universal reference_  – 一种可以解析为lvalue reference或者rvalue reference的引用。对于某个被推导的类型`T`，universal references 总是以  `T&&`  的形式出现。

（2）引用折叠_是 会让 universal references (其实就是一个处于引用折叠背景下的rvalue references ) 有时解析为 lvalue references 有时解析为 rvalue references 的根本机制。引用折叠只会在一些特定的可能会产生"引用的引用"场景下生效。 这些场景包括模板类型推导，`auto`  类型推导，  `typedef`  的形成和使用，以及`decltype`  表达式。

（3）std::move与std::forward本质都是`static_cast`转换，**对于右值引用使用std::move，对于万能引用使用std::forward。**std::move解决的问题是对于一个本身是左值的右值引用变量需要绑定到一个右值上，所以需要使用一个能够传递右值的工具，而std::move就干了这个事。而std::forward解决的问题是一个绑定到universal reference上的对象可能具有 lvalueness 或者 rvalueness，正是因为有这种二义性，所以催生了`std::forward`: 如果一个本身是 左值 的 万能引用如果绑定在了一个 右边值 上面，就把它重新转换为右值。函数的名字 (“`forward`”) 的意思就是。**我们希望在传递参数的时候，可以保存参数原来的lvalueness 或 rvalueness，即是说把参数转发给另一个函数。**

（4）移动语义使得在 C++ 里返回大对象（如容器）的函数和运算符成为现实，因 而可以提高代码的简洁性和可读性，提高程序员的生产率。



完美转发使**接收任意数量实参的函数模板成为可能**，它可以将实参转发到其他的函数，使目标函数接收到的实参与被传递给转发函数的实参保持一致。    

**右值引用**是连接这移动语义和完美转发的胶合剂。它是使移动语义和完美转发变得可能的基础语言机制。

你对这些特点越熟悉，你就越会发现，你的初印象只不过是冰山一角。移动语义、完美转发和右值引用的世界比它所呈现的更加微妙。举个例子，**std::move并不移动任何东西，完美转发也并不完美**。移动操作并不永远比复制操作更廉价；即便如此，它也并不总是像你期望的那么廉价。而且，它也并不总是被调用，即使在当移动操作可用的时候。构造“`type&&`”也并非总是代表一个右值引用。

无论你挖掘这些特性有多深，它们看起来总是还有更多隐藏起来的部分。幸运的是，它们的深度总是有限的。这部分将会带你到最基础的部分。一旦到达，C++11的这部分特性将会具有非常大的意义。比如，你会掌握`std::move`和`std::forward`的惯用法。你能够适应“`type&&`”的歧义性质。你会理解移动操作的令人惊奇的不同表现的背后真相。这些片段都会豁然开朗。在这一点上，你会重新回到一开始的状态，因为移动语义、完美转发和右值引用都会又一次显得直截了当。但是这一次，它们不再使人困惑。

在本小节中，非常重要的一点是要牢记形参永远是**左值**，即使它的类型是一个右值引用。比如，假设

`void f(Widget&& w);` 

形参`w`是一个**左值**，即使它的类型是一个rvalue-reference-to-`Widget`（在函数里可以取 w的地址）。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTcwNzg0MzA1MCwtNDgyNDU4MTIyLC01ND
cxNTY2MjgsLTIzODYzMzk5Miw4MjUzNDk1OSwtMTI1NjAyNTEy
LC05NDA2MzM1NjIsLTI0Njc1ODU4MCwxNTA2OTg3ODgsLTE0ND
U0MjI3OTAsOTQxNzczODM0LC0xNjQ4MDU1ODA5LC0xMTgyMjQx
NDUzLDEyMTkxMTg4OTIsNDU4NTMzOTQwLC05ODk1ODMwNDcsLT
M1MTIxNzYxMiwtMTAzNDc3MjY0MywxNDQ0MTQ5Mjk3LC0xNjgw
OTEzNzE3XX0=
-->