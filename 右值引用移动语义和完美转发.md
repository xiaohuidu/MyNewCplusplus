[<< [Back](https://github.com/xiaohuidu/MyNewCplusplus/blob/af63fde92e4824261e7ecb7e1e189c6f5001c2b3/C++11%E6%96%B0%E7%89%B9%E6%80%A7.md)
#### 2.1 右值引用，移动语义和完美转发
#### 2.1.1 在学习std::move() 和std::forward() 之前， 要先了解**左值**和**右值**
左值和右值的区分: <u>可以取地址则为左值， 不可取地址则为右值。</u>
- **左值**: 是表达式结束后依然存在的 <u>持久对象 </u>(代表一个在内存中占有确定位置的对象),  <u>可以取地址</u>，具名变量或对象。
- **右值**是表达式结束时不再存在的<u>临时对象</u>(不在内存中占有确定位置的表达式), <u>不可以取地址</u>，没有名字。
```c
int a;
int b;

a = 3;
b = 4;
a = b;
b = a;

// 以下写法不合法。
3 = a;
a + b = 4;
```
- **左值引用**:  就是对左值的引用，给左值取别名。<u>主要作用是避免对象拷贝。</u>
```
// 以下几个是对左值的左值引用
int& ra = a; 
int*& rp = p; 
int& r = *p; 
const int& rb = b;
```
- **右值引用**: 就是对右值的引用，给右值取别名。<u>主要作用是把延长对象的生命周期，一般是延长到作用域的scope之外。</u>
右值引用的加入是C++ 11 最重大语言特性之一。从实践角度讲，它能够完美解决C++中长久以来为人所诟病的<u>临时对象效率问题</u>。从语言本身讲，它健全了C++中的引用类型在左值右值方面的缺陷。从库设计者的角度讲，它给库设计者又带来了一把利器。从库使用者的角度讲，不动一兵一卒便可以获得“免费的”效率提升。
`右值引用的表示是在具体的变量类型名称后加两个 &，比如：int&& rr = 4;。`
```
// 以下几个是对上面右值的右值引用
int&& rr1 = 10; 
double&& rr2 = x + y; 
double&& rr3 = fmin(x, y);
```
>注意：
右值引用 引用 右值，会**使右值被存储到特定的位置**。
也就是说，右值引用变量其实是左值，可以对它取地址和赋值（const右值引用变量可以取地址但不可以赋值，因为 const 在起作用）。
当然，取地址是指取变量空间的地址（右值是不能取地址的）。
比如：
1.  double&& rr2 = x + y;　　
&rr2;　
rr2 = 9.4;　　
右值引用 rr2 引用右值 x + y 后，该表达式的返回值被存储到特定的位置，不能取表达式返回值 x + y 的地址，但是可以取 rr2 的地址，也可以修改 rr2 。 
2. const double&& rr4 = x + y;　　
&rr4;　　
可以对 rr4 取地址，但不能修改 rr4，即写成rr4 = 5.3;会编译报错

现在我们知道**左值引用可以引用左值，右值引用可以引用右值**。  
那么_左值引用是否可以引用右值？右值引用是否可以引用左值呢？_
-   **左值引用可以指向右值，但需要const来修饰，不能修改这个值**
```c
// 1.左值引用只能引用左值
int t = 8;
int& rt1 = t;
//int& rt2 = 8; // 编译报错，因为8是右值，不能直接引用右值

// 2.但是const左值引用既可以引用左值
const int& rt3 = t;
const int& rt4 = 8; // 也可以引用右值 const int& rt4本质上也是一个常量，指向一个不能被修改的右值，也是安全的
const double& r1 = x + y;
const double& r2 = fmin(x, y);
```
>问：为什么const左值引用也可以引用右值**？
答：在 C++11标准产生之前，是没有右值引用这个概念的，当时如果想要一个类型既能接收左值也能接收右值的话，需要用const左值引用，比如标准容器的 push_back 接口：void push_back (const T& val)。
也就是说，如果const左值引用不能引用右值的话，有些接口就不好支持了。  
另外，const左值引用，本意上是指向一个不被（该引用本身）它修改的内存区域，本质上这个引用变量本身也就是一个常量，至于这个内存区域对应一个全局变量、局部变量、xvalue，无所谓啊

下面就是 C++98标准中相关接口const左值引用引用右值的例子：
```
vector<int> v;
v.push_back(1);
v.push_back(2);
v.push_back(3);
```
-   **右值引用可以指向左值，需要std::move(v)即可**
> std::move（C++11），作用是将一个左值强制转化为右值，以**实现移动语义**。左值被 move 后变为右值，于是右值引用可以引用。
```c
// 1.右值引用只能引用右值
int&& rr1 = 10;
double&& rr2 = x + y;
const double&& rr3 = x + y;

int t = 10;
//int&& rrt = t; // 编译报错，不能直接引用左值

// 2.但是右值引用可以引用被move的左值
int&& rrt = std::move(t);
int*&& rr4 = std::move(p);
int&& rr5 = std::move(*p);
const int&& rr6 = std::move(b);
```
-   **声明出来的左值引用或右值引用都是左值**

**左值引用的使用场景和实际意义**: 避免内存的拷贝， 节省内存， 提高效率。
- 当**引用作为参数**的时候，其效果跟利用指针作为参数的效果相当。当调用函数时，函数中的形参就会被当成实参变量或者对象的一个别名使用，也就是说**函数中对形参的各种操作实际上就是对实参本身的操作**，而非简单的实参变量或者对象的值拷贝给形参
```
void func1(string s)
{...}

void func2(const string& s)
{...}


int main()
{
    string s1("Hello World!");
    func1(s1);  // 由于是传值传参且做的是深拷贝，代价较大
    func2(s1);  // 左值引用做参数减少了拷贝，提高了效率    
                //通常函数调用时采用值传递的方式，系统会在内存中开辟空间用来存储形参变量，并将实参变量的值拷贝给形参变量，所以形参变量只是实参变量的副本而已，并且如果函数传递的是类的对象，系统还会调用类中的拷贝构造函数来构造形参对象    
                //使用引用作为参数传递时，由于此时形参只是传递函数的实参变量或者对象的别名而非副本，故系统不会耗费时间在内存中开辟空间来存储形参，因此如果参数传递的数据较大，建议使用引用作为函数的形参，提高函数的时间效率，节省内存空间    
                //指针作为函数的形参，虽然达到的效果跟使用引用一样，但当调用函数时仍然需要为形参指针分配空间，引用则不需要【引用在底层也会分配指针大小的空间，在汇编底层角度，引用和指针是一样的，不过引用类似于常量指针】。
                //推荐使用引用而非指针作为函数的传递函数
    return 0;
}
```
- 左值引用**做返回值**（仅限于对象出了函数作用域以后还存在的情况）
```c
string s2("hello"); 
// string operator+=(char ch) 传值返回存在拷贝且是深拷贝 
// string& operator+=(char ch) 左值引用做返回值没有拷贝，提高了效率
s2 += '!';
```
- **左值引用的不足**: 
当对象（对象是函数内的局部对象）出了函数作用域以后不存在时，就不可以使用左值引用返回了。
```c
string operator+(const string& s, char ch)
{
	string ret(s);
	ret.push_back(ch);
	return ret;
}

// 拿现在这个函数来举例：ret是函数内的局部对象，出了函数作用域后会被析构，即被销毁了
// 若此时再返回它的别名（左值引用），也就是再拿这个对象来用，就会出问题

/*
①：不能返回局部变量的引用。局部变量会在函数返回后被销毁，此时对 局部变量的引用就会成为“无所指”的引用，程序会进入未知状态。
②：不能返回函数内部通过 new 分配的内存的引用。虽然不存在局部变量的被动销毁问题，但如果被返回的函数的引用只是作为一个临时变量出现，而没有将其赋值给一个实际的变量，    那么就可能造成这个引用所指向的空间（有 new 分配）无法释放的情况（由于没有具体的变量名，故无法用 delete 手动释放该内存），从而造成内存泄漏。
*/
```
于是，对于**第二种情形**，左值引用也无能为力，只能传值返回

**右值引用的使用场景和实际意义**:  为了解决上述传值返回的拷贝问题，C++11标准就增加了**右值引用** 和 **移动语义**。
-  **返回函数的局部变量**
```c
QList<Pin*> getModelPins() const
{
    QList<Pin*> pins;
    for (auto& pin : m_lstPins) {
        pins << pin.data();
    }
    return std::move(pins);
}

//-->>调用

QList<Pin*> getInstModelPins(std::string instId) const
{
    auto inst = d->getInst(instId);
    if (inst) {
        auto pins = inst->getModelPins();
        return std::move(pins);
    }
    return QList<Pin*>();
}
#### 2.1.2 std:move()
```
-  **C++11标准的STL 容器接口**
除了上面的使用场景之外，C++11标准的STL 容器的相关接口函数也增加了右值引用版本
![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201151655274-574842866.png)
#### 2.1.2 移动语义
使编译器有可能**用廉价的移动操作来代替昂贵的拷贝操作**。正如拷贝构造函数和拷贝赋值操作符给了你控制拷贝语义的权力，**移动构造函数和移动赋值操作符也给了你控制移动语义的权力**。移动语义也允许创建只可移动（_move-only_）的类型，例如`std::unique_ptr`，`std::future`和`std::thread`

将一个对象中的资源移动到另一个对象（资源控制权的转移）
1)  **移动构造函数**: 转移参数右值的资源来构造自己
```c
// 这是一个模拟string类的实现的移动构造
string(string&& s):_str(nullptr), _size(0), _capacity(0)
{
	swap(s);
}
```
**拷贝构造函数**和**移动构造函数**都是构造函数的重载函数，所不同的是：

-   拷贝构造函数的参数是  **const左值引用，接收左值或右值**；
-   移动构造函数的参数是**右值引用，接收右值或被 move 的左值**。

> 当传来的参数是右值时，虽然拷贝构造函数可以接收，但是编译器会认为移动构造函数更加匹配，就会调用移动构造函数。

总的来说，如果这两个函数都有在类内定义的话，在构造对象时：

-   若是**左值做参数**，那么就会调用拷贝构造函数，做一次**拷贝**（如果是像 string 这样的在堆空间上存在资源的类，那么**每调用一次拷贝构造就会做一次深拷贝**）。
-   若是**右值做参数**，那么就会调用移动构造，而调用移动构造就会**减少拷贝**（如果是像 string 这样的在堆空间上存在资源的类，那么**每调用一次移动构造就会少做一次深拷贝**）。

比如执行下面这几行代码：
```c
string s("Hello World11111111111111111"); 
string s1 = s; // s是左值，所以调用拷贝构造函数
string s2 = move(s); // s被move后变为右值，所以调用移动构造函数，s的资源会被转移用来构造s2 
					// 要注意的是，move一般是不这样用的，因为s的资源被转走了
```
![执行前后内存情况:](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201143849477-1773655910.png)

**移动构造函数有无的区别**: 
比如执行语句 cout << MyLib::to_string(1234) << endl;
- **只有拷贝构造，没有移动构造**

![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201144808042-640790079.png)

**在 to_string 函数栈帧销毁前，用局部对象 str  拷贝构造出临时对象返回到函数调用处【此时str也被成为将亡值，返回的是右值】**

![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201144921741-1784150596.png)

- **既有拷贝构造， 又有移动构造**

![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201145058159-1898728599.png)

**在 to_string 函数栈帧销毁前，用局部对象 str （反正 str 要销毁，将 str 视为右值，直接转移 str 的资源 ）移动构造出临时对象返回到函数调用处**

![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201145212017-1609779550.png)

**编译器一般会做一些优化**:
比如执行语句MyLib::string ret = MyLib::to_string(1234); 

1）只有拷贝构造， 没有移动构造

![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201145342848-1222428997.png)

**因为临时对象有 ret 来接收，这样的话临时对象的创建和销毁就显得多余了，不如省略掉这一步，直接用 str 拷贝构造出 ret**

![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201145452232-1002914911.png)

2）既有拷贝构造， 又有移动构造

![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201145714218-1241979520.png)

**因为临时对象有 ret 来接收，先拷贝构造出临时对象再用它移动构造出 ret ，临时对象好像没必要产生一样，不如省略掉。既然 str 是 to_string 函数栈帧的局部对象，最后还是要销毁，不如将 str 视为右值，直接转移 str 的资源用来构造 ret ，也就是直接用 str 移动构造出 ret**

![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201145845475-711590615.png)

2) **移动赋值**和移动构造类似.
```c
// 这是一个模拟string类的实现的移动赋值
string& operator=(string&& s)
{
　　swap(s);
　　return *this;
}
```

#### 2.1.3 std::move()
-   std::move作用主要可以将一个**左值转换成右值引用**，从而可以调用C++11右值引用的拷贝构造函数
-   std::move应该是针对你的对象中有在**堆上分配内存**这种情况而设置的。
- 若对一个对象做move操作，就不要声明为 const. 因为对const对象的move请求会执行到copy操作上

```
// move example
#include <utility>      // std::move
#include <iostream>     // std::cout
#include <vector>       // std::vector
#include <string>       // std::string

int main () {
  std::string foo = "foo-string";
  std::string bar = "bar-string";
  std::vector<std::string> myvector;

  myvector.push_back (foo);                    // copies
  myvector.push_back (std::move(bar));         // moves

  std::cout << "myvector contains:";
  for (std::string& x:myvector) 
	  std::cout << ' ' << x;
  std::cout << '\n';

  return 0;
}
```
在分析std::move()之前， 首先看remove_reference 的源码:
`remove_reference`的作用是去除`T`中的引用部分，只获取其中的类型部分。无论`T`是左值还是右值，最后**只获取它的类型部分**。
```c
template<typename _Tp> struct remove_reference
{ 
	typedef _Tp   type; 
};
 
// 特化版本
template<typename _Tp> struct remove_reference<_Tp&>
{ 
	typedef _Tp   type; 
};
 
template<typename _Tp> struct remove_reference<_Tp&&>
{ 
	typedef _Tp   type; 
};
```
`std::move()` 源码:
```c
// FUNCTION TEMPLATE move
template <class _Ty> _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept 
{ // forward _Arg as movable
    return static_cast<remove_reference_t<_Ty>&&>(_Arg);
}
```
std::move的功能是：

-   **传递的是左值**，推导为左值引用，仍旧static_cast**转换为右值引用**。    
-   **传递的是右值**，推导为右值引用，仍旧static_cast**转换为右值引用**。    
-   在返回处，直接范围右值引用类型即可。还是通过renive_reference获得_Tp类型，然后直接type&&即可。

所以std::remove_reference<_Tp>::type&&，就是一个右值引用，我们就知道了std::move干的事情了。

#### 2.1.3   转发(forwarding)


使**接收任意数量实参的函数模板成为可能**，它可以将实参转发到其他的函数，使目标函数接收到的实参与被传递给转发函数的实参保持一致。    

**右值引用**是连接这移动语义和完美转发的胶合剂。它是使移动语义和完美转发变得可能的基础语言机制。

你对这些特点越熟悉，你就越会发现，你的初印象只不过是冰山一角。移动语义、完美转发和右值引用的世界比它所呈现的更加微妙。举个例子，**std::move并不移动任何东西，完美转发也并不完美**。移动操作并不永远比复制操作更廉价；即便如此，它也并不总是像你期望的那么廉价。而且，它也并不总是被调用，即使在当移动操作可用的时候。构造“`type&&`”也并非总是代表一个右值引用。

无论你挖掘这些特性有多深，它们看起来总是还有更多隐藏起来的部分。幸运的是，它们的深度总是有限的。这部分将会带你到最基础的部分。一旦到达，C++11的这部分特性将会具有非常大的意义。比如，你会掌握`std::move`和`std::forward`的惯用法。你能够适应“`type&&`”的歧义性质。你会理解移动操作的令人惊奇的不同表现的背后真相。这些片段都会豁然开朗。在这一点上，你会重新回到一开始的状态，因为移动语义、完美转发和右值引用都会又一次显得直截了当。但是这一次，它们不再使人困惑。

在本小节中，非常重要的一点是要牢记形参永远是**左值**，即使它的类型是一个右值引用。比如，假设

`void f(Widget&& w);` 

形参`w`是一个**左值**，即使它的类型是一个rvalue-reference-to-`Widget`（在函数里可以取 w的地址）。

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE2NjcwMTk3MjEsNDk1MTA1NTYyXX0=
-->