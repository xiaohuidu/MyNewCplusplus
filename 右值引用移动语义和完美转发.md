<< [Back](https://github.com/xiaohuidu/MyNewCplusplus/blob/af63fde92e4824261e7ecb7e1e189c6f5001c2b3/C++11%E6%96%B0%E7%89%B9%E6%80%A7.md)
####  右值引用，移动语义和完美转发
#### 1.  左值和右值，左值引用和右值引用的定义
左值和右值的区分: **可以取地址则为左值， 不可取地址则为右值**。
- **左值(lvalue）**: 是表达式结束后依然存在的 **持久对象** (代表一个在内存中占有确定位置的对象),  可以取地址，具名变量或对象。
- **右值(rvalue)**是表达式结束时不再存在的**临时对象**(不在内存中占有确定位置的表达式), 不可以取地址，没有名字。
```c
赋值运算符(=)左边只能出现左值， 右边可以是左值或者右值。
int a;
int b;

a = 3;
b = 4;
a = b;
b = a;

// 以下写法不合法。
3 = a;
a + b = 4; // a+ b是右值， 不能出现在 复制运算符= 的左边
```
- **左值引用（lvalue reference）**:  就是对左值的引用，给左值取别名。主要作用是**避免对象拷贝**。
左值引用的表示是**在具体的变量类型名称后加 &**:
```
// 以下几个是对左值的左值引用
int& ra = a; 
int*& rp = p; 
int& r = *p; 
const int& rb = b;
```
- **右值引用(rvalue reference)**: 就是对右值的引用，给右值取别名。主要作用是把**延长对象的生命周期**，一般是延长到作用域的scope之外。
右值引用的表示是**在具体的变量类型名称后加 &&**:

```c 
int&& rr = 4;
double&& rr2 = x + y; 
double&& rr3 = fmin(x, y);
```
> 右值引用的加入是C++ 11 最重大语言特性之一。\
> 从实践角度讲，它能够完美解决C++中长久以来为人所诟病的**临时对象效率问题**。\
> 从语言本身讲，它健全了C++中的引用类型在左值右值方面的缺陷。\
> 从库设计者的角度讲，它给库设计者又带来了一把利器。\
> 从库使用者的角度讲，不动一兵一卒便可以获得“免费的”效率提升。

**左值引用和右值引用本身都是左值**

右值引用 引用 右值，会**使右值被存储到特定的位置**。
也就是说，**右值引用变量其实是左值**，**可以对它取地址**和赋值（const右值引用变量可以取地址但不可以赋值，因为 const 在起作用）。
当然，取地址是指取变量空间的地址（**右值是不能取地址的**）。
比如：
1.  double&& rr2 = x + y;　　\
&rr2;　\
rr2 = 9.4;　　\
右值引用 rr2 引用右值 x + y 后，该表达式的返回值被存储到特定的位置，不能取表达式返回值 x + y 的地址，但是可以取 rr2 的地址，也可以修改 rr2 。 
2. const double&& rr4 = x + y;　　\
&rr4;　　\
可以对 rr4 取地址，但不能修改 rr4，即写成rr4 = 5.3;会编译报错

 #### 2. 左值引用和右值引用的指向
-   **左值引用可以指向左值， 也可以指向右值，但需要const来修饰，不能修改这个值**
```c
// 1.左值引用只能引用左值
int t = 8;
int& rt1 = t;
//int& rt2 = 8; // 编译报错，因为8是右值，不能直接引用右值

// 2.但是const左值引用既可以引用左值, 也可以引用右值
const int& rt3 = t;
const int& rt4 = 8; //  const int& rt4本质上也是一个常量，指向一个不能被修改的右值，也是安全的
const double& r1 = x + y;
const double& r2 = fmin(x, y);
```
**>问：为什么const左值引用也可以引用右值？** \
答：在 C++11标准产生之前，是没有右值引用这个概念的，当时如果想要一个类型既能接收左值也能接收右值的话，需要用const左值引用，比如标准容器的 push_back 接口：void push_back (const T& val)。
也就是说，如果const左值引用不能引用右值的话，有些接口就不好支持了。  
另外，const左值引用，本意上是指向一个不被（该引用本身）它修改的内存区域，本质上这个引用变量本身也就是一个常量，至于这个内存区域对应一个全局变量、局部变量、xvalue，无所谓啊

下面就是 C++98标准中相关接口const左值引用引用右值的例子：
```
vector<int> v;
v.push_back(1);
v.push_back(2);
v.push_back(3);
```
-   **右值引用可以指向右值， 也可以指向左值，需要std::move(v)即可**
> std::move（C++11），作用是将一个左值强制转化为右值，以**实现移动语义**。左值被 move 后变为右值，于是右值引用可以引用。
```c
// 1.右值引用只能引用右值
int&& rr1 = 10;
double&& rr2 = x + y;
const double&& rr3 = x + y;

int t = 10;
//int&& rrt = t; // 编译报错，不能直接引用左值

// 2.但是右值引用可以引用被move的左值
int&& rrt = std::move(t);
int*&& rr4 = std::move(p);
int&& rr5 = std::move(*p);
const int&& rr6 = std::move(b);
```

看一下下面这个例子:
```cpp
template<typename T>
class Widget {
    ...
    Widget(Widget&& rhs);        // rhs类型是右值引用, 但它本身是个左值
    ...                          
};
```
在 Widget 的构造函数当中,  `rhs`  是一个右值引用，**前面提到，右值引用只能被绑定到右值上**，所以我们知道它被绑定到了一个右值上面(i.e., 因此我们需要传递了一个rvalue给它)， 但是  `rhs`  本身是一个 左值，所以，当我们想要用到这个被绑定在  `rhs`  上的右值的 rvalueness 的时候，我们就需要把  `rhs`  转换回一个rvalue。之所以我们想要这么做，是因为我们想将它作为一个移动操作的source，这就是为什么我们**用  `std::move`将它转换回一个  `rvalue`**。
#### 3. 万能引用(universal reference)
**并不是所有出现&&的地方都是右值引用, 有可能是万能引用**
```cpp
Widget&& var1 = someWidget; // here, “&&” means rvalue reference 
auto&& var2 = var1; // here, “&&” does not mean rvalue reference
 
template<typename T>
void f(std::vector<T>&& param); // here, “&&” means rvalue reference
 
template<typename T>
void f(T&& param); // here, “&&”does not mean rvalue reference
```

类型声明当中的“`&&`”有的时候意味着右值引用，但有的时候意味着右值引用或者左值引用。因此，源代码当中出现的 “`&&`” 有可能是 “`&`” 的意思，即是说，语法上看着像右值引用 (“`&&`”)，但实际上却代表着一个左值引用 (“`&`”)。 我没给它起个名字叫**万能引用**(universal reference)

**如果一个变量或者参数被声明为T&&，其中T是被推导的类型，那这个变量或者参数就是一个万能引用。**

万能指针存在于下面几种情况:
- **函数模板的参数**。
- **使用auto的时候**。
- **typedef**
- **decltype**

**万能引用的initializer决定了它到底代表的是左值引用 还是 右值引用**:

-   如果**用来初始化universal reference的表达式是一个左值**，那么universal reference就变成**lvalue reference**。
-   如果**用来初始化universal reference的表达式是一个右值**，那么universal reference就变成**rvalue reference**。

上述可以根据下面代码例子理解：
```cpp
template<typename T> void f(T&& param); 
```

假设你是`initializer`：
```cpp
int a;
f(a);   // 传入左值,那么上述的T&& 就是lvalue reference,也就是左值引用绑定到了左值
f(1);   // 传入右值,那么上述的T&& 就是rvalue reference,也就是右值引用绑定到了左值
```
`auto` 和模版类似。
```cpp
Widget&& var1 = someWidget;
auto&& var2 = var1; // var2 定义为一个universial reference, 
					// 赋值左值引用后， 变成了左值引用（var1 变量本身是左值）
```
**只有在发生类型推导的时候  “`&&`” 才代表 universal reference** 。**如果没有类型推导，就没有universal reference**。这种时候，类型声明当中的“`&&`”总是代表着rvalue reference。因此，如下代码没有发生类型推导， &&代表rvalue reference:
```cpp
template<typename T> void f(T&& param); // 需要类型推导， 所以是万能引用
 
template<typename T>
class Widget {
    ...
    Widget(Widget&& rhs); // 不存在类型推导， 所以是右值引用(注意rhs变量本身是左值)
};
 
template<typename T1>
class Gadget {
    ...
    template<typename T2>
    Gadget(T2&& rhs);// 需要类型推导 T2, 所以是万能引用
};
 
void f(Widget&& param); //不需要类型推导， 所以是右值引用
```
`Gadget`  构造函数当中的`rhs`  是一个万能引用, 所以它可能绑定到一个左值或者右值上，但是无论它被绑定到什么东西上，`rhs`  本身还是一个 左值。

如果它被绑定到一个右值并且我们想利用这个右值的 rvalueness， 我们就要重新将  `rhs`  转换回一个rvalue。如果它被绑定到一个左值上，当然我们就不想把它当做 右值。

**一个绑定到万能引用上的对象可能具有左值性或者右值性，正是因为有这种二义性，所以催生了`std::forward`**: 如果一个本身是 lvalue 的 universal reference 如果绑定在了一个 rvalue 上面，就把它重新转换为rvalue。函数的名字 (“`forward`”) 的意思就是，我们希望在传递参数的时候，**可以保存参数原来的lvalueness 或 rvalueness，即是说把参数转发给另一个函数**。

**特别注意, 下面这段代码， 其实是没有类型推导的:**
```cpp
template<typename T> 
void f(std::vector<T>&& param); //其实不需要类型推导， 所以是右值引用     
```

这里，我们同时有类型推导和一个带“`&&`”的参数，但是参数却不具有 “`T&&`” 的形式，而是 “`std::vector<t>&&`”。其结果就是，参数就只是一个**普通的rvalue reference**，而不是万能引用。 

**万能引用只以 “`T&&`”的形式出现！即便是仅仅加一个const限定符都会使得“`&&`”不再被解释为万能引用**:
```cpp
template<typename T>
void f(const T&& param);               // “&&” means rvalue reference
```

**有的时候你可以在函数模板的声明中看到`T&&`，但却没有发生类型推导**。来看下`std::vector`的  `push_back`  函数:[3]
```cpp
template <class T, class Allocator = allocator<T> >
class vector {
public:
    ...
    void push_back(T&& x); //其实类型是确定的 vector<T>, 所以是右值引用
};
```

这里,  `T`  是模板参数, 并且`push_back接受一个``T&&`, 但是**这个参数却不是万能引用**! 这怎么可能?

如果我们看看`push_back在类外部是如何声明的，这个问题的答案就很清楚了。`我会假装`std::vector`的  `Allocator`  参数不存在，因为它和我们的讨论无关。我们来看看没Allocator参数的`std::vector::push_back`:

template <class T> void vector<T>::push_back(T&& x);

`push_back`不能离开`std::vector<T>`这个类而独立存在。但如果我们有了一个叫做`std::vector<T>`的类，我们就已经知道了T是什么东西，那就没必要推导T。

举个例子可能会更好。如果我这么写:
```cpp
Widget makeWidget();
std::vector<Widget> vw;

Widget w;
vw.push_back(makeWidget());      // create Widget from factory, add it to vw
```
代码中对  `push_back`  的使用会让编译器实例化类  `std::vector<Widget>`  相应的函数。这个`push_back`  的声明看起来像这样:
```
void std::vector<Widget>::push_back(Widget&& x);
```

看到了没? 一旦我们知道了类是  `std::vector<Widget>`，`push_back`的参数类型就完全确定了: 就是`Widget&&`。这里完全不需要进行任何的类型推导。

对比下  `std::vector`  的`emplace_back`，它看起来是这样的:
```cpp
template <class T, class Allocator = allocator<T> >
class vector {
public:
    ...
    template <class... Args>
    void emplace_back(Args&&... args); // deduced parameter types ⇒ type deduction;
    ...                                // && ≡ universal references
};
```
`emplace_back`  看起来需要多个参数(Args和args的声明当中都有...)，但重点是每一个参数的类型都需要进行推导。函数的模板参数  `Args`  和类的模板参数`T`无关，所以即使我知道这个类具体是什么，比如说，`std::vector<Widget>`，但我们还是不知道`emplace_back`的参数类型是什么。

我们看下在类`std::vector<Widget>`外面声明的  `emplace_back`会更清楚的表明这一点 (我会继续忽略  `Allocator`  参数):
```cpp
template<class... Args>
void std::vector<Widget>::emplace_back(Args&&... args);
```

#### 4. 值类别(value category)和值类型(value type)
“值类别”（value category）和“值类型”（value type）是两个看似相 似、却毫不相干的术语。

**值类别**: 指的是上面这些**左值、右值相关的概念**。
**值类型**: 是与引用类型（reference type）相对而言，**表明一个变量是代表实际数值，还是引用另外一个数值**。

>在C++ 里，所有的原生类型、枚举、结构、联合、类都代表值类型，只有引用（&）和指针（*）才是引用类型。\
>在 Java 里，数字等原生类型是值类型，类则属于引用类型。\
>在Python 里，一切类型都是引用类型。

**一个表达式的左值性(lvalueness)或者右值性(rvalueness)和它的类型无关。**

来看下  `int`。可以有lvalue的`int`  (e.g., 声明为int的变量)，还有rvalue的`int`  (e.g., 字面值`10`)。用户定义类型`Widget`等等也是一样的。

一个`Widget`对象可以是lvalue(e.g., a  `Widget`  变量) 或者是rvalue (e.g., 创建`Widget的`工程函数的返回值)。

**表达式的类型不会告诉你它到底是个左值还是右值**。因为表达式的左值或 右值 独立于它的类型，我们就可以有一个 左值，但它的类型确却是右值引用，也可以有一个 右值引用 类型的右值 :
```
Widget makeWidget(); // factory function for Widget 
Widget&& var1 = makeWidget() // var1 is an lvalue, but
							// its type is rvalue reference (to Widget) 
Widget var2 = static_cast<Widget&&>(var1); // the cast expression yields an rvalue, but
                                           // its type is rvalue reference  (to Widget)
```
`var1`类别是左值，但它的类型是右值引用。`static_cast<Widget&&>(var1)`表达式是个右值，但它的类型是右值引用。

把 lvalues (例如  `var1`) 转换成 rvalues 比较常规的方式是对它们调用`std::move`，所以  `var2`  可以像这样定义:
```c
Widget var2 = std::move(var1);             // equivalent to above
```

我最初的代码里使用  `static_cast`  仅仅是为了显示的说明这个表达式的类型是个rvalue reference (`Widget&&`)。rvalue reference 类型的具名变量和参数是 lvalues。(你可以对他们取地址。)

**std::move() 只是把左值转换成右值， 不会调用移动构造函数。 但是static_cast<Widget&&>(var1) 会调用移动构造函数**（如果没有定义， 则会调用拷贝构造函数） 构造一个临时对象， 然后赋给 var2. 比如下面的例子:
```cpp
#include <iostream>
using namespace std;

class Widget {
public:
        Widget() {
                cout << "The default constructor is called" << endl;
        }
        Widget(Widget &w) {
                cout << "The copy constructor is called" << endl;
        }

        Widget(Widget &&w) {
                cout << "The move constructor is called" << endl;
        }

        ~Widget(){
                cout << "The destructor is called" << endl;
        }
};

int main() {
        Widget w1, w11;
        Widget &w2 = w1;
        Widget &&w3 = move(w1);
        Widget w4 = static_cast<Widget&&>(w11);
        Widget w5 = move(w3);
        Widget &&w6 = move(w11);
        Widget w7 = w1;
        return 0;
}
```
输出结果:
```cpp
The default constructor is called  // w1 默认构造函数构造
The default constructor is called // w11 默认构造函数构造
The move constructor is called // Widget w4 = static_cast<Widget&&>(w11), 移动构造函数被调用
The move constructor is called // Widget w5 = move(w3), 调用移动构造函数构造对象。
The copy constructor is called // Widget w7 = w1 调用拷贝构造函数。
The destructor is called
The destructor is called
The destructor is called
The destructor is called
The destructor is called
```

#### 5. 左值引用的使用场景和实际意义: 避免内存的拷贝， 节省内存， 提高效率。
- 当**引用作为参数**的时候，其效果跟利用指针作为参数的效果相当。当调用函数时，函数中的形参就会被当成实参变量或者对象的一个别名使用，也就是说**函数中对形参的各种操作实际上就是对实参本身的操作**，而非简单的实参变量或者对象的值拷贝给形参
```
void func1(string s)
{...}

void func2(const string& s)
{...}


int main()
{
    string s1("Hello World!");
    func1(s1);  // 由于是传值传参且做的是深拷贝，代价较大
    func2(s1);  // 左值引用做参数减少了拷贝，提高了效率    
                //通常函数调用时采用值传递的方式，系统会在内存中开辟空间用来存储形参变量，并将实参变量的值拷贝给形参变量，所以形参变量只是实参变量的副本而已，并且如果函数传递的是类的对象，系统还会调用类中的拷贝构造函数来构造形参对象    
                //使用引用作为参数传递时，由于此时形参只是传递函数的实参变量或者对象的别名而非副本，故系统不会耗费时间在内存中开辟空间来存储形参，因此如果参数传递的数据较大，建议使用引用作为函数的形参，提高函数的时间效率，节省内存空间    
                //指针作为函数的形参，虽然达到的效果跟使用引用一样，但当调用函数时仍然需要为形参指针分配空间，引用则不需要【引用在底层也会分配指针大小的空间，在汇编底层角度，引用和指针是一样的，不过引用类似于常量指针】。
                //推荐使用引用而非指针作为函数的传递函数
    return 0;
}
```
- 左值引用**做返回值**（仅限于对象出了函数作用域以后还存在的情况）
```c
string s2("hello"); 
// string operator+=(char ch) 传值返回存在拷贝且是深拷贝 
// string& operator+=(char ch) 左值引用做返回值没有拷贝，提高了效率
s2 += '!';
```
- **左值引用的不足**: 
当对象（对象是函数内的局部对象）出了函数作用域以后不存在时，就不可以使用左值引用返回了。
```c
string operator+(const string& s, char ch)
{
	string ret(s);
	ret.push_back(ch);
	return ret;
}

// 拿现在这个函数来举例：ret是函数内的局部对象，出了函数作用域后会被析构，即被销毁了
// 若此时再返回它的别名（左值引用），也就是再拿这个对象来用，就会出问题

/*
①：不能返回局部变量的引用。局部变量会在函数返回后被销毁，此时对 局部变量的引用就会成为“无所指”的引用，程序会进入未知状态。
②：不能返回函数内部通过 new 分配的内存的引用。虽然不存在局部变量的被动销毁问题，但如果被返回的函数的引用只是作为一个临时变量出现，而没有将其赋值给一个实际的变量，    那么就可能造成这个引用所指向的空间（有 new 分配）无法释放的情况（由于没有具体的变量名，故无法用 delete 手动释放该内存），从而造成内存泄漏。
*/
```
于是，对于**第二种情形**，左值引用也无能为力，只能传值返回

#### 6. 右值引用的使用场景和实际意义:  为了解决上述传值返回的拷贝问题，C++11标准就增加了右值引用和移动语义。
-  **返回函数的局部变量**

为了方便对临时对象的使用，C++ 对临时对象有特殊的生命周期延长规则。这条规则是：**如果一个 局部变量 被绑定到一个引用上，它的生命周期则会延长到跟这个引用变量一样长**

```c
QList<Pin*> getModelPins() const
{
    QList<Pin*> pins;
    for (auto& pin : m_lstPins) {
        pins << pin.data();
    }
    return std::move(pins);
}

//-->>调用

QList<Pin*> getInstModelPins(std::string instId) const
{
    auto inst = d->getInst(instId);
    if (inst) {
        auto pins = inst->getModelPins();
        return std::move(pins);
    }
    return QList<Pin*>();
}
```

-  **C++11标准的STL 容器接口**
除了上面的使用场景之外，C++11标准的STL 容器的相关接口函数也增加了右值引用版本
![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201151655274-574842866.png)

#### 7.   **引用折叠**
这个问题的核心是，C++11当中的一些构造会弄出来引用的引用，而**C++不允许出现引用的引用**。如果代码当中显式的出现了一个引用的引用，那代码就是不合法的:

```cpp
Widget w1;
...
Widget& & w2 = w1;               // error! No such thing as “reference to reference”
```

但是，有些情况下，在你对类型进行操作的时候可能会搞出来引用的引用，编译器如果对这种情况报错是不对的。我们从C++98/C++03标准的时候就知道这件事了。

在对一个 universal reference 的模板参数进行类型推导时候，同一个类型的 lvalues 和 rvalues 被推导为稍微有些不同的类型。具体来说，**类型T的lvalues被推导为T&**(i.e., lvalue reference to  `T`)，而**类型T的 rvalues 被推导为  `T。`**(注意，虽然 lvalue 会被推导为lvalue reference，但 rvalues 却不会被推导为 rvalue references!) 我们来看下分别用rvalue和lvalue来调用一个接受universal reference的模板函数时会发生什么:

```cpp
template<typename T>
void f(T&& param);
 
...
 
int x;
 
...
 
f(10);                           // invoke f on rvalue
f(x);                            // invoke f on lvalue
```

当用rvalue 10调用 f 的时候, T被推导为 int，实例化的 f 看起来像这样:

```cpp
void f(int&& param);             // f instantiated from rvalue
```

这里一切都OK。但是当我们用lvalue x 来调用 f 的时候，T 被推导为int&，而实例化的 f 就包含了一个引用的引用:

```cpp
void f(int& && param);           // initial instantiation of f with lvalue
```

因为这里出现了引用的引用，这实例化的代码乍一看好像不合法，但是像– “`f(x)`” –这么写代码是完全合理的。为了避免编译器对这个代码报错，**C++11引入了一个叫做“引用折叠”(reference collapsing)的规则来处理某些像模板实例化这种情况下带来的"引用的引用"的问题**。

因为有两种类型的引用 (lvalue references 和 rvalue references)，那"引用的引用"就有四种可能的组合: lvalue reference to lvalue reference, lvalue reference to rvalue reference, rvalue reference to lvalue reference, 以及 rvalue reference to rvalue reference。

引用折叠只有两条规则:
-   **一个 rvalue reference to an rvalue reference 会变成 (“折叠为”) 一个 rvalue reference**.
-   **所有其他种类的"引用的引用" (i.e., 组合当中含有lvalue reference) 都会折叠为 lvalue reference**.

在用lvalue实例化 f 时，应用这两条规则，会生成下面的合法代码，编译器就是这样处理这个函数调用的:

```cpp
void f(int& param); // instantiation of f with lvalue after reference collapsing
```

上面的内容精确的说明了一个 universal reference 是如何在经过类型推导和引用折叠之后，可以变为一个 lvalue reference的。实际上，universal reference 其实只是一个身处于引用折叠背景下的rvalue reference。

**当一个变量本身的类型是引用类型的时候，这里就有点难搞了。这种情况下，类型当中所带的引用就被忽略了**。例如:

```cpp
int x; 
... 
int&& r1 = 10; // r1’s type is int&& 
int& r2 = x; // r2’s type is int&
```

在调用模板函数  `f`  的时候  `r1`  `和 r2`  的类型都被当做 int。这个扒掉引用的行为，和"universal references 在类型推导期间，lvalues 被推导为  `T&`  ，rvalues 被推导为"T" 这条规则无关。所以，这么调用模板函数的时候:

```cpp
template<typename T>
void f(T &&param) {
    static_assert(std::is_lvalue_reference<T>::value, "T& is lvalue reference");
    cout << "T& is lvalue reference" << endl;
}

int main() {
    int x;
    int &&r1 = 10;
    int &r2 = x;
    f(r1);
    f(r2);
}

```

`r1`  和`r2`  的类型都被推导为  `int&`。这是为啥呢?

首先，`r1`  和  `r2`  的引用部分被去掉了(留下的只是 int)。然后，因为它们都是 lvalues 所以当调用 f，对 universal reference 参数进行类型推导的时候，得到的类型都是int&。

我前面已经说过，引用折叠只发生在“像是模板实例化这样的场景当中”。 声明`auto`变量是另一个这样的场景。推导一个universal reference的  `auto`  变量的类型，在本质上和推导universal reference的函数模板参数是一样的，所以类型  `T`  的lvalue被推导为  `T&`，类型 T 的rvalue被推导为  `T`。我们再来看一下本文开头的实例代码:

```cpp
Widget&& var1 = someWidget; // var1 is of type Widget&& (no use of auto here) 
auto&& var2 = var1; // var2 is of type Widget& (see below)
```

`var1`  的类型是  `Widget&&`，但是它的 reference-ness 在推导  `var2`  类型的时候被忽略了;`var1`  这时候就被当做 Widget。

因为它是个lvalue，所以初始化一个`universal reference`(`var2`)的时候，`var1`  的类型就被推导成`Widget&`。在  `var2`  的定义当中将 auto 替换成`Widget&`  会生成下面的非法代码:

```cpp
Widget& && var2 = var1;          // note reference-to-reference
```

而在引用折叠之后，就变成了:

```cpp
Widget& var2 = var1;             // var2 is of type Widget&
```

还有第三种发生引用折叠的场景，就是**形成和使用  `typedef`  的时候**。看一下这样一个类模板，

```cpp
template<typename T>
class Widget {
    typedef T& LvalueRefType;
    ...
};
int main() {
    Widget<int&> w;
}
```

根据引用折叠的规则：

-   一个 rvalue reference to an rvalue reference 会变成 (“折叠为”) 一个 rvalue reference.
-   所有其他种类的"引用的引用" (i.e., 组合当中含有lvalue reference) 都会折叠为 lvalue reference.

我们知道T会被推导为lvalue reference，因此结果肯定是lvalue reference,对应于上述规则，我们来通过代码验证。

```cpp
template<typename T>
class Widget {
    typedef T& LvalueRefType;
    typedef T&& RvalueRefType;
public:
    void judge() {
        static_assert(std::is_lvalue_reference<LvalueRefType>::value, "LvalueRefType & is lvalue reference");
        static_assert(std::is_lvalue_reference<RvalueRefType>::value, "RvalueRefType & is lvalue reference");
        cout << "LvalueRefType and RvalueRefType is lvalue reference" << endl;
    }
};
int main() {
    Widget<int&> w;
}
```

输出：

```cpp
LvalueRefType and RvalueRefType is lvalue reference
```

如果我们在应用引用的上下文中使用这个typedef，例如:

```text
void f(Widget<int&>::LvalueRefType&& param);
```

在对  `typedef`  扩展之后会产生非法代码:

```cpp
void f(int& && param);
```

但引用折叠这时候又插了一脚进来，所以最终的声明会是这样:

```cpp
void f(int& param);
```

最后还有一种场景会有引用折叠发生，就是**使用  `decltype`**。和模板和  `auto`  一样，`decltype`  对表达式进行类型推导时候可能会返回  `T`  或者  `T&`，然后`decltype`  会应用 C++11 的引用折叠规则。

好吧，  `decltype`  的类型推导规则其实和模板或者  `auto`  的类型推导不一样。这里的细节过于晦涩，所以就放在  [Further Information section](https://link.zhihu.com/?target=http%3A//isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers%23FurtherInformation)  里讲解，但是我们需要注意这样一个区别，即  `decltype`  对一个具名的、非引用类型的变量，会推导为类型  `T`  (i.e., 一个非引用类型)，在相同条件下，`模板`和  `auto`  却会推导出  `T&`。

还有一个重要的区别就是`decltype`  进行类型推导只依赖于  `decltype`  的表达式; 用来对变量进行初始化的表达式的类型(如果有的话)会被忽略。因此:

```cpp
Widget w1, w2; 
auto&& v1 = w1;   
decltype(w1)&& v2 = w2; 
```

v1本身是左值，根据`auto&&`知道为万能引用，因此v1被推导为指向w1的左值引用。

w2是左值，`decltype(w1)`推导为`Widget`，因此v2为右值引用，根据右值引用只能绑定到右值，这里却给了一个左值，因此不能编译！

#### 7.  移动语义
移动语义是 C++11 中新增的一个语言特性，它允许将**一个对象的所有权从一个对象转移到另一个对象，而不需要进行数据的拷贝**。这种转移可以在对象生命周期的任意时刻进行，可以说是一种轻量级的复制操作。移动语义是通过右值引用来实现的。

移动语义使编译器有可能**用廉价的移动操作来代替昂贵的拷贝操作**。正如拷贝构造函数和拷贝赋值操作符给了你控制拷贝语义的权力，**移动构造函数和移动赋值操作符也给了你控制移动语义的权力**。移动语义也允许创建只可移动（_move-only_）的类型，例如`std::unique_ptr`，`std::future`和`std::thread`

将一个对象中的资源移动到另一个对象（资源控制权的转移）
#### 1)  **移动构造函数**: 转移参数右值的资源来构造自己
```cpp
// 这是一个模拟string类的实现的移动构造
string(string&& s):_str(nullptr), _size(0), _capacity(0)
{
	swap(s);
}
```
**拷贝构造函数**和**移动构造函数**都是构造函数的重载函数，所不同的是：

-   拷贝构造函数的参数是  **const左值引用，接收左值或右值**；
-   移动构造函数的参数是**右值引用，接收右值或被 move 的左值**。

> 当传来的参数是右值时，虽然拷贝构造函数可以接收，但是编译器会认为移动构造函数更加匹配，就会调用移动构造函数。

总的来说，如果这两个函数都有在类内定义的话，在构造对象时：

-   若是**左值做参数**，那么就会调用拷贝构造函数，做一次**拷贝**（如果是像 string 这样的在堆空间上存在资源的类，那么**每调用一次拷贝构造就会做一次深拷贝**）。
-   若是**右值做参数**，那么就会调用移动构造，而调用移动构造就会**减少拷贝**（如果是像 string 这样的在堆空间上存在资源的类，那么**每调用一次移动构造就会少做一次深拷贝**）。

比如执行下面这几行代码：
```c
string s("Hello World11111111111111111"); 
string s1 = s; // s是左值，所以调用拷贝构造函数
string s2 = move(s); // s被move后变为右值，所以调用移动构造函数，s的资源会被转移用来构造s2 
					// 要注意的是，move一般是不这样用的，因为s的资源被转走了
```
![执行前后内存情况:](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201143849477-1773655910.png)

**移动构造函数有无的区别**: 
比如执行语句 cout << MyLib::to_string(1234) << endl;
- **只有拷贝构造，没有移动构造**

![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201144808042-640790079.png)

**在 to_string 函数栈帧销毁前，用局部对象 str  拷贝构造出临时对象返回到函数调用处【此时str也被成为将亡值，返回的是右值】**

![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201144921741-1784150596.png)

- **既有拷贝构造， 又有移动构造**

![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201145058159-1898728599.png)

**在 to_string 函数栈帧销毁前，用局部对象 str （反正 str 要销毁，将 str 视为右值，直接转移 str 的资源 ）移动构造出临时对象返回到函数调用处**

![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201145212017-1609779550.png)

**编译器一般会做一些优化**:
比如执行语句MyLib::string ret = MyLib::to_string(1234); 

- 只有拷贝构造， 没有移动构造

![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201145342848-1222428997.png)

**因为临时对象有 ret 来接收，这样的话临时对象的创建和销毁就显得多余了，不如省略掉这一步，直接用 str 拷贝构造出 ret**

![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201145452232-1002914911.png)

- 既有拷贝构造， 又有移动构造

![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201145714218-1241979520.png)

**因为临时对象有 ret 来接收，先拷贝构造出临时对象再用它移动构造出 ret ，临时对象好像没必要产生一样，不如省略掉。既然 str 是 to_string 函数栈帧的局部对象，最后还是要销毁，不如将 str 视为右值，直接转移 str 的资源用来构造 ret ，也就是直接用 str 移动构造出 ret**

![enter image description here](https://github.com/xiaohuidu/MyNewCplusplus/blob/master/images/1561260-20230201145845475-711590615.png)

#### 2) **移动赋值**和移动构造类似.
```c
// 这是一个模拟string类的实现的移动赋值
string& operator=(string&& s)
{
　　swap(s);
　　return *this;
}
```
#### 3） std::move() 函数
-   std::move作用主要可以将一个**左值转换成右值引用**，从而可以调用C++11右值引用的移动构造函数
-   std::move应该是针对你的对象中有在**堆上分配内存**这种情况而设置的。
- 若对一个对象做move操作，就不要声明为 const. 因为对const对象的move请求会执行到copy操作上

```
// move example
#include <utility>      // std::move
#include <iostream>     // std::cout
#include <vector>       // std::vector
#include <string>       // std::string

int main () {
  std::string foo = "foo-string";
  std::string bar = "bar-string";
  std::vector<std::string> myvector;

  myvector.push_back (foo); // 拷贝构造
  myvector.push_back (std::move(bar)); // 移动构造

  std::cout << "myvector contains:";
  for (std::string& x:myvector) 
	  std::cout << ' ' << x;
  std::cout << '\n';

  return 0;
}
```
又一个例子：
```cpp
include <iostream>
using namespace std;

class Widget {
public:
	Widget() {
		cout << "The default constructor is called" << endl;
	}
	Widget(Widget &w) {
		cout << "The copy constructor is called" << endl;
	}

	Widget(Widget &&w) {
		cout << "The move constructor is called" << endl;
	}

	~Widget(){
		cout << "The destructor is called" << endl;
	}
};

int main() {
	Widget w1;
	Widget w2 = move(w1); // 移动构造函数会被调用
	return 0;
}
```


在分析std::move()源代码之前， 首先看remove_reference 的源码:
`remove_reference`的作用是去除`T`中的引用部分，只获取其中的类型部分。无论`T`是左值还是右值，最后**只获取它的类型部分**。
```c
template<typename _Tp> struct remove_reference
{ 
	typedef _Tp   type; 
};
 
// 特化版本
template<typename _Tp> struct remove_reference<_Tp&>
{ 
	typedef _Tp   type; 
};
 
template<typename _Tp> struct remove_reference<_Tp&&>
{ 
	typedef _Tp   type; 
};
```
`std::move()` 源码:
```c
// FUNCTION TEMPLATE move
template <class _Ty> _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept 
{ // forward _Arg as movable
    return static_cast<remove_reference_t<_Ty>&&>(_Arg);
}
```
std::move的功能是：

-   **传递的是左值**，推导为左值引用，仍旧static_cast**转换为右值引用**。    
-   **传递的是右值**，推导为右值引用，仍旧static_cast**转换为右值引用**。    
-   在返回处，直接范围右值引用类型即可。还是通过renive_reference获得_Tp类型，然后直接type&&即可。

所以std::remove_reference<_Tp>::type&&，就是一个右值引用，我们就知道了std::move干的事情了。


#### 2.1.4   转发(forwarding)
对于  `template <typename T> foo(T&&)`这样的代码。

-   如果传递过去的参数是左值，T 的推导结果是左值引用，那 T&& 的结果仍然是左值引用——即 T& && 坍缩成了T&
-   如果传递过去的参数是右值，T 的推导结果是参数的类型本身。那 T&& 的结果自然就是一个右值引用。

例如：

```cpp
void foo(const shape&)
{
	puts("foo(const shape&)");
}
void foo(shape&&)
{
	puts("foo(shape&&)");
}
void bar(const shape& s)
{
	puts("bar(const shape&)");
	foo(s);
}
void bar(shape&& s)
{
	puts("bar(shape&&)");
	foo(s);
}
int main()
{
	bar(circle());
}
```

输出：

```cpp
bar(shape&&)
foo(const shape&）
```

bar中传入的是右值，调用bar的`&&`重载函数，但是对于`void bar(shape&& s)`来说，s本身是一个lvalue，所以在foo(s)后，仍旧调用的是`&`重载函数。

如果想要调用`foo(shape&&)`，可以：

```cpp
foo(std::move(s))
```

或者：

```cpp
foo(static_cast<shape&&>(s)
```

再考虑下面这个例子：

```cpp
void foo(const shape&)
{
	puts("foo(const shape&)");
}
void foo(shape&&)
{
	puts("foo(shape&&)");
}
template <typename T>
void bar(T&& s)
{
	foo(std::forward<T>(s));
}
int main() {
    circle temp;
    bar(temp);
    bar(circle());
}
```

输出：

```cpp
foo(const shape&)
foo(shape&&)

```

上面提到过**一个绑定到universal reference上的对象可能具有 lvalueness 或者 rvalueness，正是因为有这种二义性**,所以催生了`std::forwar()`: 如果一个本身是 lvalue 的 universal reference 如果绑定在了一个 rvalue 上面，就把它重新转换为rvalue。函数的名字 (“`forward`”) 的意思就是，我们希**望在传递参数的时候，可以保存参数原来的lvalueness 或 rvalueness，即是说把参数转发给另一个函数**。

因为在 T 是模板参数时，T&& 的作用主要是保持值类别进行转发，它有个名字就叫“转发引用”（forwarding reference）。因为既可以是左值引用，也可以是右值引用，它也曾经被叫做“万能引用”（universal reference）。

在分析``std::forward()`之前，先看看`remove_reference`，下面是`remove_reference`的实现：

```cpp
template<typename _Tp>
struct remove_reference
{ typedef _Tp   type; };

// 特化版本
template<typename _Tp>
struct remove_reference<_Tp&>
{ typedef _Tp   type; };

template<typename _Tp>
struct remove_reference<_Tp&&>
{ typedef _Tp   type; };
```

`remove_reference`的作用是去除`T`中的引用部分，只获取其中的类型部分。无论`T`是左值还是右值，最后只获取它的类型部分。

> std::forward源码剖析

-   转发左值
```cpp
template<typename _Tp> constexpr _Tp&& forward(typename 
	std::remove_reference<_Tp>::type& __t) noexcept
{ 
	return static_cast<_Tp&&>(__t); 
}
```

先获得类型type，定义`_t`为左值引用的左值变量，通过`static_cast`进行强制转换。`_Tp&&`会发生引用折叠，当`_Tp`推导为左值引用，则折叠为`_Tp& &&`，即`_Tp&`，推导为右值引用，则为本身`_Tp&&`,所以`froward`返回值与`static_cast`处都为`_Tp&&`。

-   转发右值
```cpp
template<typename _Tp>
constexpr _Tp&&
forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
{
  static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
        " substituting _Tp is an lvalue reference type");
  return static_cast<_Tp&&>(__t);
}
```
小结：

-   在《Effective Modern C++》中建议：**对于右值引用使用std::move，对于万能引用使用std::forward。**
-   std::move()与std::forward()都仅仅做了类型转换而已。真正的移动操作是在移动构造函数或者移动赋值操作符中发生的。
-   `std::move()`可以应用于左值(普通的变量int这些使用move与不使用move效果一样)，但这么做要谨慎。因为一旦“移动”了左值，就表示当前的值不再需要了，如果后续使用了该值，产生的行为是未定义。
不同于转发左值，`_t`为右值引用的左值变量，除此之外中间加了一个断言，表示当不是左值的时候，也就是右值，才进行`static_cast`转换。

小结：

-   在《Effective Modern C++》中建议：**对于右值引用使用std::move，对于万能引用使用std::forward。**
-   std::move()与std::forward()都仅仅做了类型转换而已。真正的移动操作是在移动构造函数或者移动赋值操作符中发生的。
-   `std::move()`可以应用于左值(普通的变量int这些使用move与不使用move效果一样)，但这么做要谨慎。因为一旦“移动”了左值，就表示当前的值不再需要了，如果后续使用了该值，产生的行为是未定义。

最后给个练手的例子[5]：

```cpp
void overloaded( int const &arg ) { std::cout << "by lvalue\n"; }
void overloaded( int && arg ) { std::cout << "by rvalue\n"; }

template< typename t >
/* "t &&" with "t" being template param is special, and  adjusts "t" to be
   (for example) "int &" or non-ref "int" so std::forward knows what to do. */
void forwarding( t && arg ) {
    std::cout << "via std::forward: ";
    overloaded( std::forward< t >( arg ) );
    std::cout << "via std::move: ";
    overloaded( std::move( arg ) ); // conceptually this would invalidate arg
    std::cout << "by simple passing: ";
    overloaded( arg );
}

int main() {
    std::cout << "initial caller passes rvalue:\n";
    forwarding( 5 );
    std::cout << "initial caller passes lvalue:\n";
    int x = 5;
    forwarding( x );
}

```

输出：

```cpp
initial caller passes rvalue:
via std::forward: by rvalue
via std::move: by rvalue
by simple passing: by lvalue
initial caller passes lvalue:
via std::forward: by lvalue
via std::move: by rvalue
by simple passing: by lvalue
```
 **不要返回本地变量的引用**

C++ 编程错误，是在函数里返回一个本地对象的引用。由于在函数结束时本地对象即被销毁，返回一个指向本地对象的引用属于未定义行为。

在 C++11 之前，返回一个本地对象意味着这个对象会被拷贝，除非编译器发现可以做返回值优化（named return value optimization，或 NRVO），能把对象直接构造到调用者的栈上。从 C++11 开始，返回值优化仍可以发生，但在没有返回值优化的情况下，**编译器将试图把本地对象移动出去，而不是拷贝出去**。**这一行为不需要程序员手工用 std::move 进行干预——使用std::move 对于移动行为没有帮助，反而会影响返回值优化**。

例如：

```cpp
#include <iostream> // std::cout/endl
#include <utility> // std::move
using namespace std;
class Obj {
public:
    Obj()
    {
        cout << "Obj()" << endl;
    }
    Obj(const Obj&)
    {
        cout << "Obj(const Obj&)"
             << endl;
    }
    Obj(Obj&&)
    {
        cout << "Obj(Obj&&)" << endl;
    }
};
Obj simple()
{
    Obj obj;
// 简单返回对象；一般有 NRVO
    return obj;
}
Obj simple_with_move()
{
    Obj obj;
// move 会禁止 NRVO
    return std::move(obj);
}
Obj complicated(int n)
{
    Obj obj1;
    Obj obj2;
    // 有分支，一般无 NRVO
    if (n % 2 == 0) {
        return obj1;
    } else {
        return obj2;
    }
}
int main()
{
    cout << "*** 1 ***" << endl;
    auto obj1 = simple();
    cout << "*** 2 ***" << endl;
    auto obj2 = simple_with_move();
    cout << "*** 3 ***" << endl;
    auto obj3 = complicated(42);
}

```

输出：

```cpp
*** 1 ***
Obj()
*** 2 ***
Obj()
Obj(Obj&&)
*** 3 ***
Obj()
Obj()
Obj(Obj&&)
```
## **总结**

（1）在类型声明当中， “&&” 要不就是一个 rvalue reference ，要不就是一个  _universal reference_  – 一种可以解析为lvalue reference或者rvalue reference的引用。对于某个被推导的类型`T`，universal references 总是以  `T&&`  的形式出现。

（2）_引用折叠_是 会让 universal references (其实就是一个处于引用折叠背景下的rvalue references ) 有时解析为 lvalue references 有时解析为 rvalue references 的根本机制。引用折叠只会在一些特定的可能会产生"引用的引用"场景下生效。 这些场景包括模板类型推导，`auto`  类型推导，  `typedef`  的形成和使用，以及`decltype`  表达式。

（3）std::move与std::forward本质都是`static_cast`转换，**对于右值引用使用std::move，对于万能引用使用std::forward。**std::move解决的问题是对于一个本身是左值的右值引用变量需要绑定到一个右值上，所以需要使用一个能够传递右值的工具，而std::move就干了这个事。而std::forward解决的问题是一个绑定到universal reference上的对象可能具有 lvalueness 或者 rvalueness，正是因为有这种二义性，所以催生了`std::forward`: 如果一个本身是 左值 的 万能引用如果绑定在了一个 右边值 上面，就把它重新转换为右值。函数的名字 (“`forward`”) 的意思就是。**我们希望在传递参数的时候，可以保存参数原来的lvalueness 或 rvalueness，即是说把参数转发给另一个函数。**

（4）移动语义使得在 C++ 里返回大对象（如容器）的函数和运算符成为现实，因 而可以提高代码的简洁性和可读性，提高程序员的生产率。

完美转发使**接收任意数量实参的函数模板成为可能**，它可以将实参转发到其他的函数，使目标函数接收到的实参与被传递给转发函数的实参保持一致。    

**右值引用**是连接这移动语义和完美转发的胶合剂。它是使移动语义和完美转发变得可能的基础语言机制。

你对这些特点越熟悉，你就越会发现，你的初印象只不过是冰山一角。移动语义、完美转发和右值引用的世界比它所呈现的更加微妙。举个例子，**std::move并不移动任何东西，完美转发也并不完美**。移动操作并不永远比复制操作更廉价；即便如此，它也并不总是像你期望的那么廉价。而且，它也并不总是被调用，即使在当移动操作可用的时候。构造“`type&&`”也并非总是代表一个右值引用。

无论你挖掘这些特性有多深，它们看起来总是还有更多隐藏起来的部分。幸运的是，它们的深度总是有限的。这部分将会带你到最基础的部分。一旦到达，C++11的这部分特性将会具有非常大的意义。比如，你会掌握`std::move`和`std::forward`的惯用法。你能够适应“`type&&`”的歧义性质。你会理解移动操作的令人惊奇的不同表现的背后真相。这些片段都会豁然开朗。在这一点上，你会重新回到一开始的状态，因为移动语义、完美转发和右值引用都会又一次显得直截了当。但是这一次，它们不再使人困惑。

在本小节中，非常重要的一点是要牢记形参永远是**左值**，即使它的类型是一个右值引用。比如，假设

`void f(Widget&& w);` 

形参`w`是一个**左值**，即使它的类型是一个rvalue-reference-to-`Widget`（在函数里可以取 w的地址）。



https://zhuanlan.zhihu.com/p/99524127
https://cntransgroup.github.io/EffectiveModernCppChinese/5.RRefMovSemPerfForw/item23.html
https://www.cnblogs.com/5iedu/p/11324772.html
https://www.cnblogs.com/david-china/p/17080072.html
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEzNjQxNTM1ODQsNzIxNjA5Njk1LDE3NT
EwNjI0MTQsNjA2NTMwMjAsLTIwOTI1NzUzMywtMTg2ODY3NTgz
OSwtMjA3MTM2ODkyMywtMjEyMjY3MTUxNSw1MjYxMTYzMDIsMz
IwNzI3Nzg1LDk4OTM2OTY0MiwyMDY1NzkwNjgxLDE1NTM5MDA1
OTksMTAxNDM2MDk3OSwtMTcwMjg5ODY0MCw5NzA1MjI5NzYsMT
EyOTY3NjM0MSwtMjIyNjczOTkwLC04NTAzNjI4MzUsLTY2MzQ2
NzM5XX0=
-->