## 一、为什么要使用智能指针

一句话带过：智能指针就是帮我们C++程序员管理动态分配的内存的，它会帮助我们自动释放new出来的内存，从而**避免内存泄漏**！

如果我们**分配的动态内存都交由有生命周期的对象来处理，那么在对象过期时，让它的析构函数删除指向的内存**，这看似是一个 very nice 的方案？

智能指针就是通过这个原理来解决指针自动释放的问题！

C++98 提供了 **auto_ptr** 模板的解决方案
C++11 增加**unique_ptr、shared_ptr 和weak_ptr**

## 二、auto_ptr
auto_ptr 是c++ 98定义的智能指针模板，其定义了管理指针的对象，可以将new 获得（直接或间接）的地址赋给这种对象。当对象过期时，其析构函数将使用delete 来释放内存！

**用法:**
头文件: #include < memory >
用 法: **auto_ptr<类型> 变量名(new 类型)**

例 如:
```
auto_ptr<string> str(new string(“Hello World!”));
auto_ptr<vector<int>> av(new vector<int>());
auto_ptr<int> array(new int[10]);
```

看下面这个例子：

```
class Test {
public:
	Test() { cout << "Test的构造函数..." << endl; }
	~Test() { cout << "Test的析构函数..." << endl; }

	int getDebug() { return this->debug; }

private:
	int debug = 20;
};
```
使用智能指针 auto_ptr, 不需要自己调用delete 去释放内存， 一旦离开auto_ptr 对象的作用域， auto_ptr析构函数被调用， 指向的对象也会被销毁释放:
```
// 定义智能指针
auto_ptr<Test> test(new Test);
cout << "test->debug：" << test->getDebug() << endl;
cout << "(*test).debug：" << (*test).getDebug() << endl;
```

**为什么智能指针可以像普通指针那样使用**？？？  
因为其里面重载了 * 和 -> 运算符， *** 返回普通对象，而 -> 返回指针对象**。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210720090724526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NwcF9sZWFybmVy,size_16,color_FFFFFF,t_70#pic_center)


**智能指针的三个常用函数：**

get() 获取智能指针托管的指针地址

// 定义智能指针
auto_ptr<Test> test(new Test);

Test *tmp = test.get();		// 获取指针返回
cout << "tmp->debug：" << tmp->getDebug() << endl;
1
2
3
4
5
但我们一般不会这样使用，因为都可以直接使用智能指针去操作，除非有一些特殊情况。
函数原型：

_NODISCARD _Ty * get() const noexcept
{	// return wrapped pointer
	return (_Myptr);
}
1
2
3
4
release() 取消智能指针对动态内存的托管

// 定义智能指针
auto_ptr<Test> test(new Test);

Test *tmp2 = test.release();	// 取消智能指针对动态内存的托管
delete tmp2;	// 之前分配的内存需要自己手动释放
1
2
3
4
5
也就是智能指针不再对该指针进行管理，改由管理员进行管理！
函数原型：

_Ty * release() noexcept
{	// return wrapped pointer and give up ownership
	_Ty * _Tmp = _Myptr;
	_Myptr = nullptr;
	return (_Tmp);
}
1
2
3
4
5
6
reset() 重置智能指针托管的内存地址，如果地址不一致，原来的会被析构掉

// 定义智能指针
auto_ptr<Test> test(new Test);

test.reset();			// 释放掉智能指针托管的指针内存，并将其置NULL

test.reset(new Test());	// 释放掉智能指针托管的指针内存，并将参数指针取代之
1
2
3
4
5
6
reset函数会将参数的指针(不指定则为NULL)，与托管的指针比较，如果地址不一致，那么就会析构掉原来托管的指针，然后使用参数的指针替代之。然后智能指针就会托管参数的那个指针了。
函数原型：

void reset(_Ty * _Ptr = nullptr)
{	// destroy designated object and store new pointer
	if (_Ptr != _Myptr)
		delete _Myptr;
	_Myptr = _Ptr;
}
1
2
3
4
5
6
使用建议：
————————————————

                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
                        
原文链接：https://blog.csdn.net/cpp_learner/article/details/118912592
<!--stackedit_data:
eyJoaXN0b3J5IjpbNDQwODE0Njk2LC0xMzE1MjQ0MTExLC0xNT
k3ODMyMjcwLDczMDk5ODExNl19
-->