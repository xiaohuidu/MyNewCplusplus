# 1 被弃用的特性

在学习现代 C++ 之前，我们先了解一下从 C++11 开始，被弃用的主要特性：
> **注意**：弃用并非彻底不能用，只是用于暗示程序员这些特性将从未来的标准中消失，应该尽量避免使用。但是，已弃用的特性依然是标准库的一部分，并且出于兼容性的考虑，大部分特性其实会『永久』保留。
#### 1.1  **不再允许字符串字面值常量赋值给一个  `char *`。如果需要用字符串字面值常量赋值和初始化一个  `char *`，应该使用  `const char *`  或者  `auto`。**
```c
char *str = "hello world!"; // 将出现弃用警告
```
建议用法:
```c
const char *str = "hello world!";
auto str = "hello world"
```
#### 1.2. **C++98 异常说明、  `unexpected_handler`、`set_unexpected()`  等相关特性被弃用，应该使用  `noexcept`**
#### 1.2.1 C++98 异常说明
在C++98中，**throw**关键字除了可以用在函数体中抛出异常，还可以用在函数头和函数体之间，指明当前函数能够抛出的异常类型，这称为异常规范，有些教程也称为异常指示符或异常列表。如：
```c
double  func(char  param)  throw(int);
```
函数func只能抛出int类型的异常，如果抛出其他类型的异常，try也将无法捕获，程序会被终止。
申明函数可以抛出多种类型异常：
```c
double  func(char  param)  throw(int,  char,  std::exception);
``` 
申明函数不会抛出异常：
```c
double  func(char  param)  throw();
```
此时如果申明不会抛出异常的func，在运行时抛出了异常，try无法捕获，程序终止。
异常规范的**初衷是好的**，它希望让程序员看到函数的定义或声明后，立马就知道该函数会抛出什么类型的异常，这样程序员就可以使用 try-catch 来捕获了。如果没有异常规范，程序员必须阅读函数源码才能知道函数会抛出什么异常。
不过这**有时候也不容易做到**。例如，func_outer() 函数可能不会引发异常，但它调用了另外一个函数 func_inner()，这个函数可能会引发异常。再如，编写的一个函数调用了老式的一个库函数，此时不会引发异常，但是老式库更新以后这个函数却引发了异常。
其实，不仅仅如此，
1.异常规范的检查是在运行期而不是编译期，因此程序员不能保证所有异常都得到了 catch 处理。
2.由于第一点的存在，编译器需要生成额外的代码，在一定程度上妨碍了优化。
3.模板函数中无法使用。比如下面的代码，
```c
template<class T>
void  func(T k)
{
	T x(k);
x.do_something();
}
```
赋值函数、拷贝构造函数和 do_something() 都有可能抛出异常，这取决于类型 T 的实现，所以无法给函数 func  指定异常类型。

实际使用中，我们只需要两种异常说明：抛异常和不抛异常，也就是 throw(...) 和 throw()。
所以 C++11 摒弃了 throw 异常规范，而引入了新的异常说明符 **noexcept**。



4.析构函数默认都是 noexcept  的，除非显示指定为 noexcept(false)
#### 1.2.2 unexpected_handler
 如果某个函数出现异常，而该异常未被列到异常列表，则**unexpected_handler**被系统自动调用。该函数可以调用 terminate 或者 cstdlib::exit 或者 cstdlib::abort 中止程序的执行。也可以把异常再次抛出，或者抛出别的异常。如果抛出的异常不在异常列表，而且列表里有 bad_exception，那么系统会代替它抛出 bad_exception。如果列表里没有 bad_exception，那么系统自动调用 terminate 终止程序的运行。默认的 unexpected handler 调用 terminate。
 #### 2.3 noexpect 详解
noexcept紧跟在函数的参数列表后面，它只用来表明两种状态：`不会抛异常`和`可能抛异常`。
```c
void  func_not_throw()  noexcept;  // 保证不抛出异常
void  func_not_throw()  noexcept(true);  // 同上
void  func_throw()  noexcept(false);  // 可能会抛出异常
void  func_throw();  // 同上，默认 
```
在成员函数中，noexcept说明符需要跟在const及引用限定符之后，而在final、override或虚函数的=0之前。

如果一个虚函数承诺了它不会抛出异常，则后续派生的虚函数也必须做出同样的承诺。与之相反，如果基类的虚函数允许抛出异常，则派生类的虚函数既可以抛出异常，也可以不允许抛出异常。
>注意：编译器会检查带有noexcept修饰的函数，是否存在throw语句，如果有，也仅仅只是给出warning！因为存在的throw，可以在内部被catch，不会抛到外面来。但是，当这样的函数真的throw异常到外面的时候，程序直接终止，外面有try也没有用。
 ```c
#include <iostream>
using namespace std;

void func_not_throw(void) noexcept {
    throw 1;
}

int main(void) {
    try {
        func_not_throw(); // 直接terminate，不会被catch
    } catch(...) {
        cout << "catch int" << endl;
    }

    return 0;
}
```
这段代码编译会有个warning， 运行直接挂掉
```
$ g++ -Wall -Wextra test.cpp -o test
test.cpp: In function ‘void func_not_throw()’:
test.cpp:6:5: warning: ‘throw’ will always call ‘terminate’ [-Wterminate]
    6 |     throw 1;
      |     ^~~~~~~
$ ./test
terminate called after throwing an instance of 'int'
Aborted (core dumped
```
**destructor默认为noexcept(true)，除非显示指定为noexcept(false)**。如果在destructor中抛出异常，极大的可能会导致此异常没有catch，然后程序挂掉。因为调用destructor的地方，很可能就是在异常处理流程中。因此强烈建议在destructor中将可能的异常全部处理掉。默认的noexcept(true)是OK的。

**noexcept(func())**

noexcept后面可以带上一个函数接口的调用形式，只是形式，**不会真的调用**。我理解noexcept是一个编译期间确定值的表达式，就像sizeof或decltype一样。
```c
#include <iostream>
using namespace std;

void foo() noexcept {cout<<"foo\n";}
void bar() noexcept(false) {cout<<"bar\n";}
void foo2() noexcept(noexcept(bar())) {}
void bar2() noexcept(noexcept(foo())) {}
void fp(int a) noexcept {cout<<"fp\n";}

int main(){
    cout << noexcept(foo()) << endl;
    cout << noexcept(bar()) << endl;
    cout << noexcept(foo2()) << endl;
    cout << noexcept(bar2()) << endl;
    // param is necessary，
    // but the actual value is irrelavent.
    cout << noexcept(fp(0)) << endl;
    return 0;
}
```
输出:
```
1
0
0
1
1
```
**noexcept(expression)**

noexcept还可以用来在编译器判别一个表达式是否可能throw。

> The  `noexcept`  keyword has another purpose: You can use it as an  `operator`  in an expression, and it evaluates to true if the evaluation of the argument would be considered non-throwing by the compiler. Like sizeof, the argument itself is not evaluated. 把noexcept作为得到bool值的编译期操作符，就像sizeof一样。

例如：
```
bool  example1  =  noexcept(1  +  2);  // true
bool  example2  =  noexcept(1  /  0);  // true

bool  example3  =  noexcept(
  std::declval<std::string>().clear());  // true
bool  example4  =  noexcept(
  std::declval<std::string>().resize(0));  // false
  ``` 

example1很简单，做个加法，不会throw C++ exception。

example2有点tricky，The compiler says that dividing by zero will not raise a C++ exception. Now, dividing by zero is actually undefined behavior, but the compiler isn’t performing any division here. It’s  `just checking whether operator/(int, int) is potentially-throwing, and it is not`. **编译期不会真的执行**除以0,只是通过两个int类型的除法来判断。
example3也说明了，clear接口在编译期**不会被真的调用执行**。
example4说明C++编译器只是使用resize这个接口来判定，不关心接口内的参数是什么值，也**不会真的调用执行接口**。

**noexcept带来的好处**
1.  从语义上理解，noexcept 对于程序员之间的交流是有利的，就像 const 限定符一样。
2.  显式地指定 noexcept 的函数，**编译器会进行优化**。因为在调用 noexcept 函数时不需要记录 exception handler，所以编译器可以生成更高效的二进制码（编译器是否优化不一定，但理论上 noexcept 给了编译器更多优化的机会）。另外编译器在编译一个 noexcept(false) 的函数时可能会生成很多冗余的代码，这些代码虽然只在出错的时候执行，但还是会对 Instruction Cache 造成影响，进而影响程序性能。
3.  如果**move constructor**带有noexcept修饰，在执行某些操作的时候，会选择move，以实现更好的性能。而如果move constructor没有noexcept，某些操作会选择更安全的copy constructor。（copy constructor 是 Strong Exception Guarantee，发生异常时需要还原，因为原对象的数据并没有被破坏，还原相对容易。但move constructor在执行期间如果异常了，是难以还原的。）
 ```c
#include <iostream>
#include <vector>
using namespace std;

struct A {
    A(int value):
        value{value} {
        cout << value << " constructor\n";
    }

    A(const A& other) {
        std::cout << other.value << " copy constructor\n";
        value = other.value;
    }

    A(A&& other) noexcept {
        std::cout << other.value << " move constructor\n";
        value = other.value;
    }

    int value;
};


int main(void) {
    std::vector<A> a;
    //cout << a.size() << endl;
    a.emplace_back(1);
    a.emplace_back(2);
    for (auto& x: a)
        cout << x.value << " ";
    cout << endl;
    return 0;
}
```
上面这段代码，在执行emplace_back的时候，会动态扩展vector的capicity。因为move constructor带有noexcept修饰，在动态扩展capicity的时候，编译器会选择使用move。上面代码执行输出如下：
```
$ g++ -Wall -Wextra test.cpp -o test
$ ./test
1 constructor
2 constructor
1 move constructor
1 2
```
**noexcept 使用建议**
我们所编写的函数默认都不使用noexcept，只有遇到以下的情况时，再思考是否需要使用：
1.  destructor，必须也应该为 noexcept，默认就是。
2.  构造函数（普通normal、复制copy、移动move），赋值运算符重载函数。
3.  尽量让上面的函数都是 noexcept，这可能会给你的代码带来一定的运行期执行效率。
4.  还有那些你可以 100% 保证不会 throw 的函数。
比如像是 int，pointer 这类的 getter，setter 都可以用 noexcept 修饰，因为不可能出错。但请一定要注意，不能100%保证的地方请一定不要用，否则会害人害己！切记！
5. 函数指针及该指针所指的函数必须具有一致的异常说明
6. 在 typedef 或类型别名中则不能出现 noexcept。

#### 1.3 **`auto_ptr`  被弃用，应使用  `unique_ptr`**
#### 1.3.1 auto_ptr 被弃用原因
auto_ptr 是在C++98 引入的智能指针， 设计目的是用来自动管理动态分配的对象内存。 智能指针在栈上， 所指向的对象在堆上， 一旦函数调用结束， 智能指针被自动释放， 它的析构函数会被调用， 堆上内存的释放在析构函数里自动完成。但是智能指针有一些问题到时它被弃用:
- 缺少内存所有权语义。比如下面代码
```c
auto_ptr<string> ptr1(new string("hello world"))
auto_ptr<string> ptr2
ptr2 = ptr1 
```
ptr1 和ptr2 指向同一个对象， 如果ptr2 的释放导致所指向的对象内存被释放， ptr1 还指向原来的地址， 就会出现悬浮指针， 对于ptr1的所有访问都有可能导致未知问题。
-  缺乏深拷贝语义。智能指针之间的赋值是浅拷贝， 在需要深拷贝的地方智能指针不适合。
- 智能指针的语义不是很容易被理解， 特别是在继承多态的情况下
#### 1.3.2 unique_ptr
unique_ptr 很好的解决了上面的问题。unique_ptr<> 是C++11 提供的智能指针实现之一， 用于防止内存泄漏。
- unique_ptr对象包含了一个原始指针， 并负责其生命周期。当这个对象被销毁时， 它的析构函数会释放关联的原始指针的内存。
- unique_ptr始终是关联的原始指针的唯一所有者。我们不能复制一个unique_ptr对象， 智能move.
```
std::unique_ptr<Task> taskPtr4 = std::move(taskPtr2)
```
- 因为unique_ptr是原始指针的唯一拥有者， 所以在析构函数删除关联指针内存时， 不需要任何的参考计数， 所以非常轻量级。
- 下面是一个例子:
```c
#include <iostream>
#include <memory>

struct Task {
	int mId;
	Task(int id) : mId(id) {
		std::cout << "Task::Constructor" << std::endl;
	}

	~Task() {
		std::cout << "Task::Destructor" << std::endl;
	}
};

int main() {
//通过原始指针创建unique_ptr对象
std::unique_ptr<Task> taskPtr(new Task(23));
int id = taskPtr->mId;
//通过unique_ptr访问元素
std::cout << id << std::endl;
return 0;
}
```
#### 4 xxx
# 2 新特性
#### 2.1 std::move()
在学习std::move 之前， 要先了解**左值**和**右值**
左值和右值的区分: <u>可以取地址则为左值， 不可取地址则为右值。</u>
- **左值**: 是表达式结束后依然存在的 <u>持久对象 </u>(代表一个在内存中占有确定位置的对象),  <u>可以取地址</u>，具名变量或对象。
- **右值**是表达式结束时不再存在的<u>临时对象</u>(不在内存中占有确定位置的表达式), <u>不可以取地址</u>，没有名字。
```c
int a;
int b;

a = 3;
b = 4;
a = b;
b = a;

// 以下写法不合法。
3 = a;
a + b = 4;
```
- **左值引用**:  就是对左值的引用，给左值取别名。<u>主要作用是避免对象拷贝。</u>
```
// 以下几个是对左值的左值引用
int& ra = a; 
int*& rp = p; 
int& r = *p; 
const int& rb = b;
```
- **右值引用**: 就是对右值的引用，给右值取别名。<u>主要作用是把延长对象的生命周期，一般是延长到作用域的scope之外。</u>
右值引用的加入是C++ 11 最重大语言特性之一。从实践角度讲，它能够完美解决C++中长久以来为人所诟病的<u>临时对象效率问题</u>。从语言本身讲，它健全了C++中的引用类型在左值右值方面的缺陷。从库设计者的角度讲，它给库设计者又带来了一把利器。从库使用者的角度讲，不动一兵一卒便可以获得“免费的”效率提升。
`右值引用的表示是在具体的变量类型名称后加两个 &，比如：int&& rr = 4;。`
```
// 以下几个是对上面右值的右值引用
int&& rr1 = 10; 
double&& rr2 = x + y; 
double&& rr3 = fmin(x, y);
```
>注意：
右值引用 引用 右值，会**使右值被存储到特定的位置**。
也就是说，右值引用变量其实是左值，可以对它取地址和赋值（const右值引用变量可以取地址但不可以赋值，因为 const 在起作用）。
当然，取地址是指取变量空间的地址（右值是不能取地址的）。
比如：
1.  double&& rr2 = x + y;　　
&rr2;　
rr2 = 9.4;　　
右值引用 rr2 引用右值 x + y 后，该表达式的返回值被存储到特定的位置，不能取表达式返回值 x + y 的地址，但是可以取 rr2 的地址，也可以修改 rr2 。 
2. const double&& rr4 = x + y;　　
&rr4;　　
可以对 rr4 取地址，但不能修改 rr4，即写成rr4 = 5.3;会编译报错

现在我们知道**左值引用可以引用左值，右值引用可以引用右值**。  
那么_左值引用是否可以引用右值？右值引用是否可以引用左值呢？_
-   **左值引用可以指向右值，但需要const来修饰，不能修改这个值**
```c
// 1.左值引用只能引用左值
int t = 8;
int& rt1 = t;
//int& rt2 = 8; // 编译报错，因为8是右值，不能直接引用右值

// 2.但是const左值引用既可以引用左值
const int& rt3 = t;
const int& rt4 = 8; // 也可以引用右值 const int& rt4本质上也是一个常量，指向一个不能被修改的右值，也是安全的
const double& r1 = x + y;
const double& r2 = fmin(x, y);
```
>问：为什么const左值引用也可以引用右值**？
答：在 C++11标准产生之前，是没有右值引用这个概念的，当时如果想要一个类型既能接收左值也能接收右值的话，需要用const左值引用，比如标准容器的 push_back 接口：void push_back (const T& val)。
也就是说，如果const左值引用不能引用右值的话，有些接口就不好支持了。  
另外，const左值引用，本意上是指向一个不被（该引用本身）它修改的内存区域，本质上这个引用变量本身也就是一个常量，至于这个内存区域对应一个全局变量、局部变量、xvalue，无所谓啊

下面就是 C++98标准中相关接口const左值引用引用右值的例子：
```
vector<int> v;
v.push_back(1);
v.push_back(2);
v.push_back(3);
```
-   **右值引用可以指向左值，需要std::move(v)即可**
> std::move（C++11），作用是将一个左值强制转化为右值，以**实现移动语义**。左值被 move 后变为右值，于是右值引用可以引用。
```c
// 1.右值引用只能引用右值
int&& rr1 = 10;
double&& rr2 = x + y;
const double&& rr3 = x + y;

int t = 10;
//int&& rrt = t; // 编译报错，不能直接引用左值

// 2.但是右值引用可以引用被move的左值
int&& rrt = std::move(t);
int*&& rr4 = std::move(p);
int&& rr5 = std::move(*p);
const int&& rr6 = std::move(b);
```
-   **声明出来的左值引用或右值引用都是左值**

**左值引用的使用场景和实际意义**: 避免内存的拷贝， 节省内存， 提高效率。
- 当**引用作为参数**的时候，其效果跟利用指针作为参数的效果相当。当调用函数时，函数中的形参就会被当成实参变量或者对象的一个别名使用，也就是说**函数中对形参的各种操作实际上就是对实参本身的操作**，而非简单的实参变量或者对象的值拷贝给形参
```
void func1(string s)
{...}

void func2(const string& s)
{...}


int main()
{
    string s1("Hello World!");
    func1(s1);  // 由于是传值传参且做的是深拷贝，代价较大
    func2(s1);  // 左值引用做参数减少了拷贝，提高了效率    
                //通常函数调用时采用值传递的方式，系统会在内存中开辟空间用来存储形参变量，并将实参变量的值拷贝给形参变量，所以形参变量只是实参变量的副本而已，并且如果函数传递的是类的对象，系统还会调用类中的拷贝构造函数来构造形参对象    
                //使用引用作为参数传递时，由于此时形参只是传递函数的实参变量或者对象的别名而非副本，故系统不会耗费时间在内存中开辟空间来存储形参，因此如果参数传递的数据较大，建议使用引用作为函数的形参，提高函数的时间效率，节省内存空间    
                //指针作为函数的形参，虽然达到的效果跟使用引用一样，但当调用函数时仍然需要为形参指针分配空间，引用则不需要【引用在底层也会分配指针大小的空间，在汇编底层角度，引用和指针是一样的，不过引用类似于常量指针】。
                //推荐使用引用而非指针作为函数的传递函数
    return 0;
}
```
- 左值引用**做返回值**（仅限于对象出了函数作用域以后还存在的情况）
```c
string s2("hello"); 
// string operator+=(char ch) 传值返回存在拷贝且是深拷贝 
// string& operator+=(char ch) 左值引用做返回值没有拷贝，提高了效率
s2 += '!';
```
- **左值引用的不足**: 
当对象（对象是函数内的局部对象）出了函数作用域以后不存在时，就不可以使用左值引用返回了。
```c
string operator+(const string& s, char ch)
{
string ret(s);
ret.push_back(ch);
return ret;
}

// 拿现在这个函数来举例：ret是函数内的局部对象，出了函数作用域后会被析构，即被销毁了
// 若此时再返回它的别名（左值引用），也就是再拿这个对象来用，就会出问题

/*
①：不能返回局部变量的引用。局部变量会在函数返回后被销毁，此时对 局部变量的引用就会成为“无所指”的引用，程序会进入未知状态。
②：不能返回函数内部通过 new 分配的内存的引用。虽然不存在局部变量的被动销毁问题，但如果被返回的函数的引用只是作为一个临时变量出现，而没有将其赋值给一个实际的变量，    那么就可能造成这个引用所指向的空间（有 new 分配）无法释放的情况（由于没有具体的变量名，故无法用 delete 手动释放该内存），从而造成内存泄漏。
*/
右值引用的使用场景和实际意义: 
#### 2.2

https://www.cnblogs.com/david-china/p/17080072.html
https://cplusplus.com/reference/utility/move/
https://medium.com/@lucianoalmeida1/a-little-bit-about-std-move-efd9d554c09a
https://www.cnblogs.com/shadow-lr/p/Introduce_Std-move.html



<!--stackedit_data:
eyJoaXN0b3J5IjpbLTkxMjQ4NDc1MiwtMTYwMzMyNjczNiwtMT
Q4MTc4OTU1MSwtNTYxNjY5MTg4LC0xMjY5MjQwNTcxLC02NjM0
NzAyNjYsMTcyOTczNDk1NSwtMjMyNTAxNzU3LC02NTg5MDAwMT
IsMzMzNjA0MzY3LDY0ODcwMTM0OCwtMTIyMjUzODgzNCwtNTkz
MDc0MjY2LC01OTMwNzQyNjYsMTA0Mzc0OTQ1MCwtMzIzMzQ3MT
EsLTU0NDU2Njg1OCwtMTI2MTU3MTc1MSwxOTAxMTM4NzY1LC05
MjY5OTgxMjldfQ==
-->