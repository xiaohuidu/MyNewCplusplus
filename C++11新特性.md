# 1 被弃用的特性

在学习现代 C++ 之前，我们先了解一下从 C++11 开始，被弃用的主要特性：
> **注意**：弃用并非彻底不能用，只是用于暗示程序员这些特性将从未来的标准中消失，应该尽量避免使用。但是，已弃用的特性依然是标准库的一部分，并且出于兼容性的考虑，大部分特性其实会『永久』保留。
#### 1.  **不再允许字符串字面值常量赋值给一个  `char *`。如果需要用字符串字面值常量赋值和初始化一个  `char *`，应该使用  `const char *`  或者  `auto`。**
```c
char *str = "hello world!"; // 将出现弃用警告
```
建议用法:
```c
const char *str = "hello world!";
auto str = "hello world"
```
#### 2. **C++98 异常说明、  `unexpected_handler`、`set_unexpected()`  等相关特性被弃用，应该使用  `noexcept`**
#### 2.1 C++98 异常说明
在C++98中，**throw**关键字除了可以用在函数体中抛出异常，还可以用在函数头和函数体之间，指明当前函数能够抛出的异常类型，这称为异常规范，有些教程也称为异常指示符或异常列表。如：
```c
double  func(char  param)  throw(int);
```
函数func只能抛出int类型的异常，如果抛出其他类型的异常，try也将无法捕获，程序会被终止。
申明函数可以抛出多种类型异常：
```c
double  func(char  param)  throw(int,  char,  std::exception);
``` 
申明函数不会抛出异常：
```c
double  func(char  param)  throw();
```
此时如果申明不会抛出异常的func，在运行时抛出了异常，try无法捕获，程序终止。
异常规范的**初衷是好的**，它希望让程序员看到函数的定义或声明后，立马就知道该函数会抛出什么类型的异常，这样程序员就可以使用 try-catch 来捕获了。如果没有异常规范，程序员必须阅读函数源码才能知道函数会抛出什么异常。
不过这**有时候也不容易做到**。例如，func_outer() 函数可能不会引发异常，但它调用了另外一个函数 func_inner()，这个函数可能会引发异常。再如，编写的一个函数调用了老式的一个库函数，此时不会引发异常，但是老式库更新以后这个函数却引发了异常。
其实，不仅仅如此，
1.异常规范的检查是在运行期而不是编译期，因此程序员不能保证所有异常都得到了 catch 处理。
2.由于第一点的存在，编译器需要生成额外的代码，在一定程度上妨碍了优化。
3.模板函数中无法使用。比如下面的代码，
```c
template<class T>
void  func(T k)
{
	T x(k);
x.do_something();
}
```
赋值函数、拷贝构造函数和 do_something() 都有可能抛出异常，这取决于类型 T 的实现，所以无法给函数 func  指定异常类型。

实际使用中，我们只需要两种异常说明：抛异常和不抛异常，也就是 throw(...) 和 throw()。
所以 C++11 摒弃了 throw 异常规范，而引入了新的异常说明符 **noexcept**。

对于一个函数而言，
- noexcept  说明符要么出现在该函数的所有声明语句和定义语句，要么一次也不出现。

2.函数指针及该指针所指的函数必须具有一致的异常说明。

3.在 typedef 或类型别名中则不能出现 noexcept。

4.在成员函数中，noexcept  说明符需要跟在 const 及引用限定符之后，而在 final、override 或虚函数的 =0 之前。

5.如果一个虚函数承诺了它不会抛出异常，则后续派生的虚函数也必须做出同样的承诺；与之相反，如果基类的虚函数允许抛出异常，则派生类的虚函数既可以抛出异常，也可以不允许抛出异常。

需要注意的是，编译器不会检查带有 noexcept  说明符的函数是否有 throw。

void  func_not_throw()  noexcept

{

throw 1; // 编译通过，不会报错（可能会有警告）

}

这会发生什么呢？程序会直接调用 [std::terminate](https://en.cppreference.com/w/cpp/error/terminate)，并且不会栈展开（Stack Unwinding）（也可能会调用或部分调用，取决于编译器的实现）。另外，即使你有使用 try-catch，也无法捕获这个异常。

#include <iostream>

using namespace std;

void func_not_throw() noexcept {

throw 1;

}

int main() {

try {

func_not_throw(); // 直接 terminate，不会被 catch

} catch (int) {

cout << "catch int" << endl;

}

return 0;

}

4.析构函数默认都是 noexcept  的，除非显示指定为 noexcept(false)
#### 2.2 unexpected_handler
 如果某个函数出现异常，而该异常未被列到异常列表，则**unexpected_handler**被系统自动调用。该函数可以调用 terminate 或者 cstdlib::exit 或者 cstdlib::abort 中止程序的执行。也可以把异常再次抛出，或者抛出别的异常。如果抛出的异常不在异常列表，而且列表里有 bad_exception，那么系统会代替它抛出 bad_exception。如果列表里没有 bad_exception，那么系统自动调用 terminate 终止程序的运行。默认的 unexpected handler 调用 terminate。
# 2 新特性



<!--stackedit_data:
eyJoaXN0b3J5IjpbLTUxMDEyMDA4MywtMTg2NjcyMTQ0LC0xNj
I2MTM2MDA3LC0yMzMyNDkzMzQsLTE0OTQ4NTE1MTgsLTExNjUz
NTE4MTNdfQ==
-->